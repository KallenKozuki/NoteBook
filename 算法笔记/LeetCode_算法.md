# LeetCode_算法

## 递归

### 概述

**==实现递归的三个条件：==**

+ 大问题能拆解成两个子问题
+ 子问题的求解方式和大问题一样
+ 存在最小子问题

**==实现递归的三个步骤：==**

+ 分析问题、寻找递归：明确递归函数需要做到的功能
+ 设置边界、控制递归：明确递归的结束条件
+ 设计函数、确定参数：找到相邻的两层递归之间的关系（确定函数的关系）

**==递归的意义：==**

+ 缩小问题规模
+ 可让我们不必思考中间过程

### 21 合并两个有序链表

**==解法1：递归==**	 ***T=O(m+n), S=O(m+n)***

+ 如果两个链表中有一个为空，则返回另一个
+ 判断链表头的数据域的值，假设``list1``的较小
  + 将``list1->next``指向函数``mergeTwoLists``（递归）的返回值，同时传递形参时要传入除去表头的``list1``
    + ``mergeTwoLists``的返回值就是合并后新链表的表头

  + 递归的终点是某一个链表为空

**==解法2：迭代==**	 ***T=O(m+n), S=O(1)***

+ 创建一个虚拟头，可用任意数据初始化
+ 创建一个``curr``指针指向虚拟头，该指针表示当前正在操作的结点
+ 如果两个链表都不为空
  + 对比此时两个==链表头的值==，创建一个指向==前述比较小者指针==的指针``pp``
  + 将``curr``结点的``next``指向``pp``所指向的指针所代表的结点，并且移动``curr``至该结点
  + 利用``pp``操作对应的链表指针到下一个结点
+ 进一步将非空的链表接在``curr``后面
+ 新建一个``res``指针指向虚拟头的下一个结点（在逻辑上就是链表合并后的头结点）
+ 释放虚拟头的内存，返回``res``作为答案

> 创建``dummy``是因为不知道合并后的链表头原先属于哪个链表，用``dummy``可以方便后续操作
>
> 创建指向指针的指针``pp``是因为对两个链表所进行的操作是一样的，唯独变量名不一样
>
> 所以利用一个指向指针的指针可以方便的操作需要操作的链表（节省代码量）
>
> 本质上，``curr``指针就是为了操作当前结点的指针域，而``pp``就标示了指针域应该指向的目标结点

### 83 删除排序链表中的重复元素

**==解法1：迭代==**  	***T=O(n), S=O(1)***

+ 创建快慢指针，慢指针指向头结点，快指针指向头结点的下一个结点
+ 当快指针不为空时
  + 判断此时慢指针的数据域是否等于快指针的数据域
    + 相等：快指针移向下一个结点，慢指针的指针域指向快指针结点
    + 不等：慢指针结点等于快指针结点，快指针移向下一个结点

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 问题可以分解成头指针结点``head``和后续完成了删除操作的链表的头指针``nextHead``进行对比
  + 对比结果若相等，则``head->next = nextHead->next;``

+ 上述的后续链表的删除操作遵循同一原理


### 203 移除链表元素

**==解法1：递归==**	 ***T=O(n), S=O(n)***

+ 整个链表删除特定元素，可以分解成头结点（未判断）+后续链表（判断完成）
+ 此时判断头结点的数据域是否需要被删除
  + 需要删除则将头指针移向下一个结点（后续链表的头）
  + 否则将头结点的指针域指向后续链表

**==解法2：迭代（双指针）==**	  ***T=O(n), S=O(1)***

+ 为当前链表创建一个虚拟头，虚拟头的指针域指向当前链表的头结点
+ 创建快慢指针，慢指针指向虚拟头，快指针指向链表实际的头
+ 如果快指针不为空
  + 判断快指针结点数据域的内容
    + 删除的操作是直接让慢指针结点跳过快指针，指向快指针的下一个结点，同时快指针移动至慢指针的下一个结点
    + 如果不需要删除，则慢指针移动至快指针的位置，快指针移动至下一个结点
+ 重新指定链表头为虚拟头的下一个结点
+ 释放虚拟头的内存

### 206 反转链表

**==解法1：迭代==**	  ***T=O(n), S=O(1)***

+ 利用双指针+原本的``head``指针进行迭代
+ 原本链表的头结点在反转后是尾结点，指向空，故创建一个前指针``prev``，初始化为``nullptr``
+ 再创建一个现指针``curr``，指向``head``，也就是头结点，该指针将从原链表的头遍历指尾
+ 迭代条件：``curr``指针不为空（为空代表已经将指针遍历完毕）
  + 让``head``指针指向下一个结点，为了后续移动``curr``
  + ``curr``所指向的结点的指针域改为指向``curr``的前一个结点``prev``（最开始时是``nullptr``)
  + 将``prev``移动至``curr``的位置，``curr``移动至当前``head``的位置（也就是原链表的下一个结点）

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 整个链表的反转，可以看成是头结点和后续链表整体（已经完成反转）进行反转
  + ``head->next->next = head``

+ 相邻两层递归之间的关系是头结点指针域所指向的下一层的指针域指向头结点，然后头结点指针域置空

## 动态规划

### 概述

**==本质：==**

+ 利用==历史记录==，来避免重复计算的问题，同时也需要一些==变量==来存储历史记录，一般是用==一维或者二维数组==来存储

**==求解动态规划的三大步骤：==**

1. **定义数组元素的含义**

2. **找出数组元素之间的关系式：**一般采用==归纳法==，也就是利用历史数据找找出新的元素值
3. **找到初始值**

> 在完成上述步骤后，还可以试着找下有无优化空间复杂度的方法

### 22 括号生成

**==解法：动态规划==**

+ 当清楚所有 `i<n` 时括号的可能生成排列后，对与 `i=n` 的情况，考虑整个括号排列中最左边的括号
  + 它一定是个左括号，那么一定有一个有括号和它组成一个完整的括号，认定这一对括号是相比`i=n-1`时加进来的括号
+ 剩下的`n-1`组括号要么在新增这一对括号的内部，要么在外部（右侧）
+ 推导出转移方程：`dp[i] = "(" + p + ")" + q`，其中`p+q=n-1`，且二者非负
  + `p`代表`i=p`时所有括号的排列组合，`q`表示`i=q`时所有括号的排列组合，二者在`dp`矩阵中可以获得
  + 当`p`从`0`取到`n-1`，`q`从`n-1`取到`0`之后，所有的情况就都遍历了，也就是`dp[i]`生成完毕

### 60 不同路径

**==解法1：动态规划==**		***T=O(mn), S=O(mn)***

+ 创建一个``m×n``的二维数组``dp``，每个值都代表从初始位置移动到当前位置的路径总数
+ 数组之间的关系是：``dp[i][j] = dp[i][j-1] + dp[i-1][j] ``
+ 寻找初始值，数组``dp``的首行和首列的值均为1
+ 遍历数组，求出所有值

**==解法2：动态规划（优化空间复杂度）==**  		***T=O(mn), S=O(min(m, n))***

+ 在==解法1==思路的基础上，将存储结果的数组改为一维数组``dp``，数组的长度为m和n中小的一方（假设m小）
+ 遍历该数组，初始化所有值为1
+ 将该数组滚动 n-1 次（相当于移动之后变成了一个如==解法1==中的二维数组）
  + 每滚动一次，更新``dp``中元素的值为``dp[i] += dp[i-1]``
  + 画图可得出上述的关系式（画滚动前和滚动后的数组，关系式类似==解法1==中的关系式）

### 64 最小路径和

**==解法1：动态规划==** 		***T=O(mn), S=O(mn)***

+ 创建一个与``grid``大小相同的数组``dp``，``dp[i][j]``表示移动至``grid[i][j]``的最小路径和
+ 关系：``dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j] ``
+ 初始化：数组``dp``的首行首列根据``grid``的首行首列进行初始化

**==解法2：动态规划（优化空间复杂度）==**

+ 在==解法1==的基础上，将存储结果的数组改为一个以为数组``dp``，数组的长度等于``grid``的短边
+ 后续思路***参见60 不同路径***

### 70 爬楼梯

**==解法1：动态规划==**		***T=O(n), S=O(n)***

+ 爬到第n层的最后一步，可以是从n-1层爬1层，也可以是从n-2层爬2层
+ 假设层数n和方法数量F存在 ``F(n)`` 关系，则 ``F(n)=F(n-1)+F(n-2)`` 
+ 找到上述表达式的初值，分别是n等于0、1、2时的方法数
+ 利用一个长度为``n+1``的数组，数组的索引代表==楼梯层数==，值代表==爬到当前层的方法数==，通过遍历的方法求得爬到n层有多少种方法

**==解法2：动态规划-滚动数组（对解法1的空间复杂度进行优化）==**		***T=O(n), S=O(1)***

+ 解法1中的关系式可用3位的滚动数组来实现
  + 滚动数组的第三个位置存储到达n层的方案数，前两个位置则分别存储n-2和n-1层
  + 每爬一层，后两个数据向前覆盖，第三个数据的新数据由前两层相加获得

### 72 编辑距离

**==解法：动态规划==**		***T=O(mn), S=O(mn)***

+ 假设``int n1 = word1.size()``，``int n2 = word2.size()``，则初始化一个动态规划数组``dp[n1+1][n2+1]``
  + 当两个单词中有一个长度为0时，至少需要长度1来正确的生成数组，此时就是个一维数组，代表其中一个单词为空串
+ 数组``dp``每个元素表示的是最少需要几步才能转换至==某种状态==
+ 到达``dp[i][j]``有三种出发点，出发点``dp[i-1][j]``表示增加，``dp[i][j-1]``表示删除，``dp[i-1][j-1]``表示替换
+ 则动态规划的关系为：``dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) ``
  + 补充，如果``word1[i-1]==word2[j-1]``则，此时不需要变换，也就是``dp[i][j] = dp[i-1][j-1]``
  + 如果两个单词均不为空串，那么开始对比的节点是``i=1, j=1``，此时找字符串中对应的位置就需要减1
+ 初始化：当某一个单词为空串时，变换的次数等于另一个单词的长度
  + 故``dp[0][0]=0 //两个单词均为空串``
  + ``dp[i][0] = i``，``dp[0][j] = j``

### 121 买卖股票的最佳时机

**==解法：一次遍历（动态规划演变而来）==** 	***T=O(n), S=O(1)***

+ 核心思想：每天都在考虑当天的最大收益
  + 假设在某天打算==卖出==，那么在==这天之前==的==股价最低==的那天==买入==是收益最高的做法
+ 遍历数组，记录遍历过的元素中的最低值，记录每天的最大收益，遍历结束后找出每天最大收益中的最大值

> 上述最低值并不是数组中的最低值，而是遍历过程中，遍历过的数据中的最低值（动态最低值）

### 198 打家劫舍

**==解法1：动态规划==**		***T=O(n), S=O(n)***

+ 动态规划数组为一维数组``dp[]``
+ ``dp[i]``的含义是如果有``i``间房，那么``dp[i]``就是最大收益
+ 转移方程：``dp[i] = max(dp[i-1], dp[i-2]+nums[i])``
  + 需要需要偷第 i 间的话，那么 i-1 间就不能偷
  + 如果不偷第 i 间，那么 i-1 间就可以偷
  + 在上述两个策略中选择较大者作为最佳策略

+ 初始状态，只有一间时，有``dp[0] = nums[0]``，只有两间时，``dp[1] = max(dp[1], dp[0])``

**==解法2：滚动数组（解法1的优化以降低空间复杂度）==**		***T=O(n), S=O(1)***

+ 不需要用``dp[]``来存储数据，只需要用一个大小为3的滚动数组即可

### 213 打家劫舍II

**==解法：动态规划（滚动数组）==**

+ 核心思路（转移方程等）与 ***198 打家劫舍*** 一致，唯一的区别在于
  + 因为本题头尾元素相连接，所以头尾元素只能选一个
  + 那么就分成了两种情况：
    + 盗窃第一间，最后一间不偷：1~n-1
    + 第一间不偷，盗窃最后一间：2~n
+ 再利用==两个==滚动数组，遍历一次``nums[]``数组即可求出上述两种情况对应的最大收益，大的一方就是答案

## 深度优先搜索

### 概述

**==概念：==**

+ 深度优先搜索（Depth First Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 V 的所在边都被探寻过或者搜索时节点不满足条件时，搜索将==回溯==到发现节点 V 的那条边的起始节点。整个过程反复进行直到所有节点都被访问为止。

**==分类：==**

+ 中序遍历
  + 先遍历二叉树的左子树，然后遍历二叉树的根结点，最后遍历二叉树的右子树
+ 前序遍历
  + 先遍历二叉树的根结点，然后遍历二叉树的左子树，最后遍历二叉树的右子树
+ 后序遍历
  + 先遍历二叉树的左子树，然后遍历二叉树的右子树，最后遍历二叉树的根结点

### 题型总结：岛屿问题通解

**==岛屿系列问题：==**

+ [200 岛屿数量](#200)
+ [463 岛屿的周长](#463)
+ [695 岛屿的最大面积](#695)

**==网格类问题的DFS遍历方法：==**

**二叉树的遍历：**二叉树的遍历有两个方向，分别是==左子树==和==右子树==，且所有节点都不会重复遍历，遇到空节点返回

**网格类的遍历：**网格可以看成是无向图，每个节点都有四个方向，分别是上下左右，有==重复遍历==的可能，==超出网格边界返回==

相比于二叉树的DFS，网格类需要解决三个问题：

+ 如何判断是否超出网格边界：==判断下标是否超出网格边界==
+ 如何判断是否重复遍历：遍历过一个岛屿节点（也就是``'1'``）后，将值改为``'2'``，代表这是遍历过的岛屿
+ 如何访问某一节点的相邻节点：二维数组的两个下标加一减一即可

**==岛屿问题DFS的框架代码：==**

```c++
void dfs(vector<vector<char>>& grid, int r, int c){
    //判断是否越界
    if(!inArea(grid, r, c)) return;
    //判断是否岛屿块
    if(grid[r][c] != '1') return;
    //将岛屿块改为已遍历过的状态
    grid[r][c] = '2';
    
    //访问周边的四个节点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

bool inArea(vector<vector<char>>& grid, int r, int c){
    return 0 <= r && r < grid.size() && 0 <= c && c < grid[0].size();
}
```

### 94 二叉树的中序遍历

**==解法1：DFS（递归）==**		***T=O(n), S=O(n)***

+ 如果当前节点不为空，访问左子树，再访问根结点，最后访问右子树
+ 左右子树的访问遵循上述规则（递归）
+ 递归的终点是当前节点为空

**==解法2：DFS（迭代）==**		***T=O(n), S=O(n)***

+ 创建一个栈用以存储访问过的父节点
+ 遍历依旧从根结点开始，但此时不需要访问根结点，而是沿着左子树一直找到叶节点
+ 遍历过程中遇到的所有节点都入栈
+ 当一个节点为空时（叶节点的左右子节点），可以利用栈顶元素访问它的父节点

> 不论是中序遍历还是前序或者后序遍历，其**迭代**实现都要：利用两个``whlie``循环实现；以及一个辅助栈

### 98 验证搜索二叉树

**==解法：DFS==**		***T=O(n), S=O(n)***

+ 中序遍历搜索二叉树，如果结果是单调递增的，则代表这是一棵二叉搜索树
+ 设置一个类内成员变量负责存储中序遍历过程中的前驱节点的值，以供后续比较

### 101 对称二叉树

**==解法1：DFS（递归）==**		***T=O(n), S=O(n)***

+ 用两个指针``q``和``p``从头结点出发，判断二叉树是否对称
+ 当``q``左移时，``p`` 右移；反之亦然
+ 移动后如果节点都不存在，则表示对称，如果只有一个存在，则表示不对称
+ 如果都存在，则判断是否相等，相等则对称（同时还要判断他们的子树是否对称，通过递归）

**==解法2：DFS（迭代）==**  	***T=O(n), S=O(n)***

+ 利用一个队列来实现递归转换为迭代，同时创建两个指针来遍历二叉树（参考解法1）
+ 初始时先将头节点入队两次，队列不为空时
  + 每次都从队头取出两个元素进行判断
    + 如果都为空，则代表对称，进入下一次判断
    + 如果只有一个为空或者值不相等，则代表不对称
  + 将取出的这两个元素的两个子节点按照正确的顺序插入队中（参考解法1）

### 104 二叉树的最大深度

**==解法：DFS（递归）==**		***T=O(n), S=O(height)***

+ 如果知道了左子树和右子树的最大深度``l``和``r``，那么二叉树的最大深度为``max(l, r) + 1 ``
+ 而左子树和右子树的最大深度可以用相同的方法计算（递归）
+ 递归在访问到空节点时退出

### 112 路径总和

**==解法：DFS（递归）==**

+ 递归函数的功能是判断当前当前节点所在路径的累加和是否等于``targetSum``
+ 该路径除了当前节点以外的部分的判别方式与上述判别方式相同（递归）

+ 套用前序遍历，访问每一个结点时，判断：
  + 如果当前节点为空，直接返回``false``（只有可能在头结点为空时出现这种状况，详见下一个条件的逻辑）
  + 如果当前节点的左右子树都为空（也就是当前节点是叶节点），那么返回``sum``和当前节点值相比较的结果
  + 每当遍历过一个节点时，``targetSum``要减去当前节点的值再传递给递归的下一级，换言之，如果当前符合题意的路径存在，那么``targetSum``到达叶节点时，等于叶节点的值

### 113 路径总和II

**==解法：DFS==**			***T=O(n^2^), S=O(n)***

+ 创建两个类成员数组，``vector<int> path``和``vector<vector<int>> allPath``，前者存储值，后者存储路径（前者）
+ 每遍历一个节点，将该节点的值放入``path``，并且``targetSum``减去当前节点的值
  + 如果该节点为叶节点并且``targetSum==0``，那么将此时的``path``放入``allPath``中（找到一条路径）
  + 如果上述条件不满足，那么继续遍历该节点的左右子树，而左右子树的遍历也遵循上述规则（递归）
+ 遍历完左右子树后从``path``中将该节点弹出

### 114 二叉树展开为链表*

**==解法1：辅助队列==**			***T=O(n), S=O(n)***

+ 前序遍历二叉树，将遍历过的节点入队
+ 遍历结束后获取队头元素，同时队头出队，将该元素左子节点置空，右子节点指向队列的下一个头
+ 直到队列为空

### 144 二叉树的前序遍历

**==解法1：递归==**				***T=O(n), S=O(n)***

+ 先访问根节点，再访问左子节点，最后访问右子节点
+ 左右子节点的访问遵循上述规则（递归）
+ 当某个节点为空时返回

**==解法2：迭代==**   		***T=O(n), S=O(n)***

+ 创建一个栈负责存储父节点
+ 创建一个``curr``指针指向``root``节点
+ 当``curr``不为空或者栈不为空时（循环）
  + 当``curr``不为空时（循环）
    + 在结果数组中加入当前``curr``的值
    + ``curr``入栈（为了后续访问其左右子节点时可以返回）
    + ``curr``移动至其左子节点处
  + 如果``curr``为空，代表上述循环结束，此时将栈顶元素赋值给``curr``
  + 栈顶元素出栈
  + ``curr``进而访问其右子节点

### <span id="200">200 岛屿数量</span>

**==解法：DFS==**		***T=O(mn), S=O(mn)***

+ 遍历数组
  + 如果数组当前元素等于``'1'``，则将该位置传入***岛屿问题DFS通用模板*** ，可以查找出一个岛屿包含的所有``'1'``
  + 每当调用一次 DFS， 则代表找到了一个岛屿

### 207 课程表



### 226 反转二叉树

**==解法：DFS（递归）==**		***T=O(n), S=O(n)***

+ 假设左子树和右子树都已经翻转完毕，则只需要交换根结点的左右子树的位置即可
+ 左子树和右子树的翻转也遵循上述规则（递归）
+ 递归在访问到空节点时直接返回

### 235 二叉搜索树的最近公共祖先

**==解法：一次遍历（利用二叉搜索树的性质）==**		***T=O(n), S=O(1)***

+ 从根结点开始遍历
  + 如果当前节点的值大于``p``和``q``的值，则当前节点移动至它的左节点
  + 如果当前节点的值小于``p``和``q``的值，则当前节点移动至它的右节点
  + 如果上述条件都不满足，则代表找到了公共祖先（和二叉搜索树的性质有关）

### 236 二叉树的最近公共祖先

**==解法：DFS（递归）==**		***T=O(n), S=O(n)***

+ 终止条件：从根结点开始遍历，如果此时``root==nullptr``或者等于``p``和``q``的其中一个，则直接返回当前的``root``
+ 递推过程：遍历左子树，返回值是``left``，遍历右子树，返回值是``right``
+ 对``left``和``right``的返回值进行判断
  + 如果==同时为空==，代表没有找到``p``和``q``，故返回``nullptr``
  + 如果==只有一个为空==，返回非空者（非空者就是公共祖先，至少包含``q``和``p``中的一个）
  + 如果==同时不为空==，代表当前节点就是公共祖先（``p``和``q``异侧）

### 337 打家劫舍III

**==解法1：后序遍历，每个节点设置加权，哈希表存储每个节点的结果==**		***T=O(n), S=O(n)***

+ 对于这棵二叉树，每个节点有两种权值，选中与不选中
  + 可以用 ***f(o)*** 表示节点 ***o*** 被选中的情况下，其子树的最大权值和
  + 用 ***g(o)*** 表示节点 ***o*** 不被选中的情况下，其子树的最大权值和
  + ***l*** 和 ***r*** 表示 ***o*** 的左右孩子
+ 当节点 ***o*** 被选中时，其左右孩子都不能被选中，故 ***f(o) = g(l) + g(r) + o.val***
+ 当节点 ***o*** 未被选中时，其左右孩子都能被选中，也可以不选中，故 ***g(o) = max{ f(l), g(l) } + max{ f(r), g(r) }***
+ 可以用一个哈希表来存储 ***f & g*** 的函数值，后续遍历二叉树可以得到每个节点的 ***f & g***

**==解法2：解法1优化空间复杂度==**		***T=O(n), S=O(n)***

+ 无论是 ***f(o) & g(o)*** ，他们的值只与 ***f(l), f(r), g(l), g(r)*** 有关，故每个节点计算后可以将节点的  ***f(o) & g(o)*** 作为一个对组返回

### 437 路径总和III

**==解法1：DFS中嵌套DFS==**			***T=O(n^2^), S=O(n)***

+ 前序遍历二叉树，对于每个节点
  + 前序遍历以当前节点为根的树，找出所有符合题意的路径

**==解法2：前缀和==**		***T=O(n), S=O(n)***

+ 前缀和的==概念==是：从根结点到当前节点的路径中所有节点的值的和
+ 创建一个成员变量哈希表，key 是前缀和，value 是这个前缀和出现的次数
+ 前序遍历二叉树，每当访问一个节点时
  + 求出到该节点的前缀和``curr``
  + 在哈希表中查找``curr-targetSum``是否存在（如果存在，则表示存在某一节点到当前节点的路径和符合条件）
  + 如果存在，则代表以该节点为终点的路径有``hashmap[curr-targerSum]``条符合条件，记此时的数量为``ret``
  + 同时，每当生成一个前缀和，都要更新哈希表
  + 递归计算==以左子树和右子树中所有节点==为==终点==的路径有几条符合条件，加至``ret``（递归函数本身的功能就是这条）
  + 当计算完成后，需要在哈希表中对当前前缀和（key）的值自减，防止重复计算

> 哈希表需要初始化``hashmap[0]=1;``，这一步是为了==保证路径以根结点为起始节点时能正确的计算结果==
>
> 比如路径``[1, 4]``且``targetSum=5``，``hashmap``中的 key 值只有两个：``1``和``5``，当在哈希表中寻找``curr-targetSum``也就是``0``时
>
> 是找不到对应的 key 值的，但实际上这条路径又是符合条件的
>
> 所以初始化``hashmap[0]=1;``可以认为是根结点有一个虚拟的前驱节点，其前缀和为``0``

### <span id="463">463 岛屿的周长</span>

**==解法1：DFS==**		***T=O(mn), S=O(mn)***

+ 本质还是参考 ***岛屿问题DFS通用模板***，如果 DFS 遍历过程中遇到==边界==或者==海洋==，则周长加一
+ DFS 中遍历过的陆地（``1``）需要改成 ``2`` ，防止重复遍历的时候重复计算

**==解法2：转换为数学问题==**		***T=O(mn), S=O(1)***

+ 因为只有一个岛屿，所以可以将问题转换为：有多少个陆地板块（``1``）相邻
  + 由数学层面易推算出：***周长 = 岛屿数量 × 4 - 相交的陆地板块对数 × 2***
+ 遍历数组，对每一个元素
  + 如果是 ``1``
    + 陆地数量加一
    + 同时判断其右边和下面等于 ``1`` 的格子有几个，每有一个 ``1`` 就代表有一对相邻的陆地板块（考虑右边界和下边界）
+ 利用公式求出岛屿周长

> 只判断每个为``1``的格子的右边和下面可以防止重复计算，也要考虑边界溢出问题

### 538 把二叉树转换为累加树

**==解法：反向中序遍历==**			***T=O(n), S=O(n)***

+ 反向中序遍历二叉搜索树即可，用一个变量来存储遍历过的所有节点的累加值

### 543 二叉树的直径

**==解法：DFS（递归）==**			***T=O(n), S=O(n)***

+ 二叉树路径的长度等于该路径经过的节点数减一，故求直径等于求经过节点数最多的路径
+ 对于一个根结点，假设其向左子树遍历经过的最多节点数为``L``，向右子树遍历经过的最多节点为``R``
  + 那么经过该根结点的最长路径的节点数为``L+R+1``
+ 定义一个递归函数求某结点最长路径的节点数``N``，函数返回该节点为根的子树的深度
+ 先递归调用左子树和右子树求出各自的深度，该节点的子树的深度则为二者中较大的一方
+ 调用过程中，记录下最长路径的节点数``L+R+1``，那么直径就是``L+R``

### 617 合并二叉树

**==解法：DFS（递归）==**			***T=O(min(m, n)), S=O(min(m, n))***

+ 假设根结点的左右子树都合并完成，则此时只需要考虑根结点的合并即可
+ 左右子树的合并遵循上述规则（递归）
+ 递归的终点是至少有一个子树为空（``root1``和``root2``）

### <span id="695">695 岛屿的最大面积</span>

**==解法：DFS==**		***T=O(mn), S=O(mn)***

+ 利用 ***岛屿问题DFS通用模板***，当 DFS 越界或者遇到非 ``1`` 的单元格时返回 ``0``
+ 如果遇到 ``1`` ，将其改为 ``2`` 防止重复遍历，同时返回值是 ``1 + 该单元格四个方向的 DFS 结果``，即可求出单个岛屿的面积

+ 找出最大的面积即可

### 733 图像渲染

**==解法：DFS==**		***T=O(mn), S=O(mn)***

+ 创建一个成员变量``edited``保存需要修改的值，如果和``color``相同，则直接返回原数组
+ 利用 ***岛屿问题DFS通用模板***，当 DFS 越界或者遇到非``edited``元素时直接返回，否则修改当前元素的值为``color``

## 回溯

### 概述

**==概念：==**

+ 采用试错的思想，尝试分步的去解决一个问题
+ 在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确解答时，他将取消上一步甚至几步的计算
+ 再通过其他分步解答再次尝试寻找答案
+ 回溯算法通常用递归实现

**==DFS和回溯的区别：==**

+ DFS是一个劲的往某个方向搜索，而回溯算法是建立在DFS的基础之上的，不同的是在搜索的过程中，达到结束条件后，回复状态，回溯上一层，再次搜索。因为二者的区别就是==有无重置状态==

**==动态规划与回溯的区别：==**

+ 共同点：用于求解多阶段的决策问题
+ 不同点：
  + 动态规划只需要我们评估最优解是多少，最优解对应的具体解是什么并没有要求，适合用于评估一个方案的效果
  + 回溯算法可以搜索得到所有的方案，本质是一种遍历算法，具有高时间复杂度

### 46 全排列

**==解法：回溯==**		***T=O(n\*n!), S=O(n)***

+ 该问题可以看作有 n 个排列成一行的空格，需要从左往右填入题目给定的 n 个数，每个数只能用一次
+ 定义`backtrack(first, output)`表示当前填到了第 ***first*** 个位置，且已经填好的排列为 ***output***
  + 如果`first==n`，代表所有数字都已填入，此时的排列就是全排列的其中之一，将其放入答案数组中，结束递归
  + 如果`first<n`，此时需要考虑这第 ***first*** 个位置我们要填哪个数
    + 为了防止填过的数字重复填入，可以用一个标记数组来表示一个数字是否已经被填入，这需要额外的空间
    + 为了节省额外的空间，我们可以将题目给定的`nums`数组分为前后两部分，左边表示填过的数，右边表示待填的数
    + 具体操作是，在填入一个数字`nums[i]`时，将其与`nums[first]`交换即可，这样能保证数组符合上述要求
    + 回溯的时候将这两个换回来即可
    + 当填好一个数字（交换过后），就可以递归继续填写下一个数字，也就是第 ***first+1***个位置

### 78 子集

**==解法1：回溯==**		***T=O(n2^n^), S=O(n)***

+ 对于每个位置而言，有==取==和==不取==两种状态，利用一个`temp`数组暂存被选中的数字

```c++
vector<int> temp;
void dfs(int cur, int n) {
    if (cur == n) {
        // 记录答案
        // ...
        return;
    }
    temp.push_back(cur);//考虑选择当前位置
    dfs(cur + 1, n, k);
    temp.pop_back();// 考虑不选择当前位置
    dfs(cur + 1, n, k);
}
```

**==解法2：迭代（枚举）==**		***T=O(n2^n^), S=O(n)***

+ 创建一个答案数组``ret``，将一个空集推入``ret``内
+ 对于``nums``中的每一个元素
  + 求出此时``ret``的长度
  + 对于``ret``中的每一个元素（本质是一个数组）
    + 将该元素取出后放入``temp``，推入``nums``此时的元素
    + 再将``temp``推入``ret``中

> 因为``nums``中所有元素各不相同，所以可以逐个累加至``ret``已有的数组中并作为新元素

## 滑动窗口

### 概述

**==概念：==**

+ 滑动窗口是一种基于双指针的思想，两个指针指向的元素之间形成的一个窗口

**==分类：==**

+ 固定大小的窗口（滚动数组）
+ 大小动态变化的窗口

**==可以解决的问题：==**

+ 给出的数据结构是数组或者字符串
+ 求取某个子串或者子序列最长最短等最值问题，或者求某个目标值时
+ 该问题本身可以暴力求解

**==需要思考的问题：==**

+ 扩大窗口时，即加入字符时，应该更新那些数据？
+ 什么条件下，窗口应该暂停扩大，开始缩小？
+ 当缩小窗口时，即移除字符时，应该更新哪些数据？
+ 我们的结果应该在扩大时更新还是缩小时更新？

**==核心思路：==**

+ 初始时，左右指针``left``和``right``都指向第0个元素，窗口为``[left, right)``，**左闭右开**，也就是初始状态时窗口内没有元素
+ 循环遍历整个数组，循环条件是``right``没有超出数组的长度
  + ``right``向右移动一个位置，更新窗口内的区间数据（可以用一个变量来表示移动``right``之后进入窗口的数据）
  + 当窗口内的数据满足我们的要求时，保持``right``不动，向右移动``left``，直到移动到一个不再满足要求的区间

> 窗口的更新和维护是最重要的一环

**==代码框架：==**

```C++
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

### 3 无重复字符的最长子串

**==解法：滑动窗口==**

+ 本题只需要考虑一个字符串，故只需要一个`window`作为哈希表
+ 初始化一个`ret=0`，表示不含重复字符的最长子串的长度，初始化一个标志位`flag=true`，表示当前子串是否不包含重复字符
+ 套用上述代码框架，针对==四个需要思考的问题：==
  + 扩大窗口时，设加入窗口的字符为`c`，更新`window[c]`
  + 如果更新后`window[c]`大于1
    + 则代表出现重复字符，此时将`flag`置反
    + 否则更新`ret`
  + 如果标志位为`false`，表示当前窗口存在重复字符，则此时需要缩小窗口
    + 同步更新`window`，直到`window[c]==1`时，更新`flag`以结束缩小窗口
  + 答案在扩大窗口时更新

### 76 最小覆盖子串

**==解法1：滑动窗口==**		***T=O(m+n\*Σ), S=O(Σ)***

+ 创建一个对组``pair<int, int> ret``保存答案，前值代表子串起始的位置，后值代表子串的长度，初始化为`(0, s.size()+1)`

+ 套用上述代码框架，针对==四个需要思考的问题：==
  + 扩大窗口时，如果能在``need``中找到加入的元素，则更新``window``，如果``window[c] == need[c]``，此时还需要更新``valid``
  + 当``valid==need.size()``时，表示当前窗口内含有``p``中的所有字符，此时开始缩小窗口
  + 当缩小窗口时
    + 如果当前窗口的长度`right-left`小于`ret.second`，则代表当前子串小于保存过的最小子串
    + 同时，如果能在``need``中找到移除的元素，进一步如果``window[c] == need[c]``，需要先更新``valid``，再更新``window``
  + 结果在每次缩小时更新
+ 最后判断`ret`的值是否与其初值相等，相等则返回空字符串，否则返回`s.substr(ret.first, ret.second)`

**==解法2：优化滑动窗口==**		***T=O(n), S=O(m)***

+ 将`t`中的每个字符出现的次数都转存至哈希表，依旧初始化左右指针`left`和`right`，同时还需要初始化一个`valid`
+ 滑动窗口的循环条件``while(right < s.size())``，目的是先找到包含所有`p`中字符的子串，然后再移动窗口寻找最小子串
  + 右指针遍历到一个新的元素`s[right]`，在哈希表中将`need[s[right]]`自减一
  + 如果`need[s[right]] >= 0`，则代表这个`s[right]`是构成`p`的字符，此时标志位`valid++`，并且右指针移动
  + 当`valid==t.size() && need[s[left]] < 0`时，表示当前子串内包含了`p`中所有的字符，且最左端的字符不属于`p`
    + 循环：将左指针在哈希表中的位置填平（自加一），然后移动左指针
  + 如果`valid==t.size()`并且区间`[left, right)`的长度小于记录过的最短子串，则更新答案

### 159 至多包含两个不同字符的最长子串

***解法与 340 完全相同，唯一区别是将 340 中的 k 改为 2***

[340 至多包含K个不同字符的最长子串](#340)

### 239 滑动窗口的最大值

**==解法：双端单调队列==**

+ 窗口滑动的过程中，数据右进左出，故可以使用队列实现，而为了找到最大值，可以使队列单调（也就是用双端队列）
+ 创建一个`right`指针来遍历数组，当`right`小于数组边界时执行循环：
  + 如果此时队列不为空且队列末尾元素小于`right`指针代表的元素，执行循环：则末尾元素出队
  + `right`元素入队
  + 计算窗口的左边界`left=right-k+1`，如果左边界大于当前队头的元素下标，则队头元素下标出队
  + 如果窗口已经形成（`left>=0`），则将当前队头（也就是当前窗口的最大值）添加到答案

### <span id=340>340  至多包含K个不同字符的最长子串</span>

**==解法：滑动窗口==**

+ 定义一个哈希表存储滑动窗口中所有字符出现的次数，定义一个`valid`变量存储滑动窗口内不同字符的种数
+ 套用上述代码框架，针对==四个需要思考的问题：==
  + 扩大窗口时
    + 如果新增的元素在哈希表中对应的频数为0，则代表这是一个不存在于窗口中的元素，`valid++`
    + 更新哈希表
    + 如果`valid<=k`，更新答案
  + 当`valid>k`时，开始缩小窗口
    + 获取被移除的元素，更新哈希表，如果更新后哈希表中该元素的频数为0，则`valid--`
  + 答案在扩大窗口时更新

### 438 找到字符串中所有的字母异位词

**==解法1：滑动窗口==**		***T=O(m+(n-m)\*Σ), S=O(Σ)***

+ 套用上述代码框架，针对==四个需要思考的问题：==

  + 扩大窗口时，如果能在``need``中找到加入的元素，则更新``window``，如果``window[c] == need[c]``，此时还需要更新``valid``

  + 本题的窗口应该是额定大小（``p.size()``），当窗口等于额定值时停止扩大，转为缩小窗口

  + 当缩小窗口时
    + 如果当前``valid``符合要求，则将当前的``left``添加至答案
    + 如果能在``need``中找到移除的元素，进一步如果``window[c] == need[c]``，需要先更新``valid``，再更新``window``
    
  + 结果在每次缩小时更新

**==解法2：优化滑动窗口==**		***T=O(n), S=O(m)***

+ 将``p``中每个字符出现的次数转存至哈希表，依旧初始化左右指针``left``和``right``
+ 依旧采用滑动窗口的循环条件``while(right < s.size())``，本循环是为了确保``[left, right)``是``p``的一个子集
  + 右指针指向的如果在哈希表中存在“余额”（`need[s[right]-'a'] > 0`），“余额”表示滑动窗口内缺少的字符
    + 减少“余额”并且移动``right``，移动后如果区间长度等于``p``的长度，则代表此区间是答案
  + 如果右指针指向的值再哈希表中不存在“余额”
    + 左指针指向元素对应的“余额”增加，同时移动左指针

> 右指针的前进必然有“余额”的铺路，也就是哈希表对应位置必须大于0，而左指针的移动则是释放被右指针占用的“余额”
>
> 移动左指针时，可能会导致哈希表中临时加入一个不属于``p``的元素的“余额”，这个“余额”在==下一次循环中==会被右指针给消除掉
>
> 换言之，``[left, right)``在移动时，如果遇到了一个不属于`p`的元素，左指针会暂时超过右指针，同时给右指针铺路
>
> 左指针在移动的过程中，就会释放掉所有被右指针占用过的“余额”，以保证后续右指针继续前进时仍有“余额”可用

### 567 字符串的排列

**==解法1：滑动窗口==**

+ 套用上述代码框架，针对==四个需要思考的问题：==

  + 扩大窗口时，如果能在``need``中找到加入的元素，则更新``window``，如果``window[c] == need[c]``，此时还需要更新``valid``

  + 本题的窗口应该是额定大小（``s1.size()``），当窗口等于额定值时停止扩大，转为缩小窗口

  + 当缩小窗口时
    + 如果当前``valid==s1.size()``，则表示当前区间符合要求，直接返回`true`
    + 如果能在``need``中找到移除的元素，进一步如果``window[c] == need[c]``，需要先更新``valid``，再更新``window``

  + 结果在每次缩小时更新


**==解法2：优化滑动窗口==**

+ 将``s1``中每个字符出现的次数转存至哈希表，依旧初始化左右指针``left``和``right``
+ 依旧采用滑动窗口的循环条件``while(right < s.size())``，本循环是为了确保``[left, right)``是``p``的一个子集
  + 如果`need[s2[right]-'a'] > 0`，也就是当前字符在哈希表中有“余额”，“余额”表示滑动窗口内缺少的字符
    + 减少“余额”并且移动右指针，移动后如果区间宽度等于`s1`的长度，则代表符合题意的子串存在，直接返回真
  + 否则对于左指针所代表的字符，释放它的”余额“（自加一），同时移动左指针

+ 如果遍历结束则代表没找到，返回假
