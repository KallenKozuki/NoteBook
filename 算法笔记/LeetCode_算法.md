# LeetCode_算法

## 递归

### 概述

**==实现递归的三个条件：==**

+ 大问题能拆解成两个子问题
+ 子问题的求解方式和大问题一样
+ 存在最小子问题

**==实现递归的三个步骤：==**

+ 分析问题、寻找递归：明确递归函数需要做到的功能
+ 设置边界、控制递归：明确递归的结束条件
+ 设计函数、确定参数：找到相邻的两层递归之间的关系（确定函数的关系）

**==递归的意义：==**

+ 缩小问题规模
+ 可让我们不必思考中间过程

### 21 合并两个有序链表

**==解法1：递归==**	 ***T=O(m+n), S=O(m+n)***

+ 如果两个链表中有一个为空，则返回另一个
+ 判断链表头的数据域的值，假设``list1``的较小
  + 将``list1->next``指向函数``mergeTwoLists``（递归）的返回值，同时传递形参时要传入除去表头的``list1``
    + ``mergeTwoLists``的返回值就是合并后新链表的表头

  + 递归的终点是某一个链表为空

**==解法2：迭代==**	 ***T=O(m+n), S=O(1)***

+ 创建一个虚拟头，可用任意数据初始化
+ 创建一个``curr``指针指向虚拟头，该指针表示当前正在操作的结点
+ 如果两个链表都不为空
  + 对比此时两个==链表头的值==，创建一个指向==前述比较小者指针==的指针``pp``
  + 将``curr``结点的``next``指向``pp``所指向的指针所代表的结点，并且移动``curr``至该结点
  + 利用``pp``操作对应的链表指针到下一个结点
+ 进一步将非空的链表接在``curr``后面
+ 新建一个``res``指针指向虚拟头的下一个结点（在逻辑上就是链表合并后的头结点）
+ 释放虚拟头的内存，返回``res``作为答案

> 创建``dummy``是因为不知道合并后的链表头原先属于哪个链表，用``dummy``可以方便后续操作
>
> 创建指向指针的指针``pp``是因为对两个链表所进行的操作是一样的，唯独变量名不一样
>
> 所以利用一个指向指针的指针可以方便的操作需要操作的链表（节省代码量）
>
> 本质上，``curr``指针就是为了操作当前结点的指针域，而``pp``就标示了指针域应该指向的目标结点

### 83 删除排序链表中的重复元素

**==解法1：迭代==**  	***T=O(n), S=O(1)***

+ 创建快慢指针，慢指针指向头结点，快指针指向头结点的下一个结点
+ 当快指针不为空时
  + 判断此时慢指针的数据域是否等于快指针的数据域
    + 相等：快指针移向下一个结点，慢指针的指针域指向快指针结点
    + 不等：慢指针结点等于快指针结点，快指针移向下一个结点

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 问题可以分解成头指针结点``head``和后续完成了删除操作的链表的头指针``nextHead``进行对比
  + 对比结果若相等，则``head->next = nextHead->next;``

+ 上述的后续链表的删除操作遵循同一原理


### 203 移除链表元素

**==解法1：递归==**	 ***T=O(n), S=O(n)***

+ 整个链表删除特定元素，可以分解成头结点（未判断）+后续链表（判断完成）
+ 此时判断头结点的数据域是否需要被删除
  + 需要删除则将头指针移向下一个结点（后续链表的头）
  + 否则将头结点的指针域指向后续链表

**==解法2：迭代（双指针）==**	  ***T=O(n), S=O(1)***

+ 为当前链表创建一个虚拟头，虚拟头的指针域指向当前链表的头结点
+ 创建快慢指针，慢指针指向虚拟头，快指针指向链表实际的头
+ 如果快指针不为空
  + 判断快指针结点数据域的内容
    + 删除的操作是直接让慢指针结点跳过快指针，指向快指针的下一个结点，同时快指针移动至慢指针的下一个结点
    + 如果不需要删除，则慢指针移动至快指针的位置，快指针移动至下一个结点
+ 重新指定链表头为虚拟头的下一个结点
+ 释放虚拟头的内存

### 206 反转链表

**==解法1：迭代==**	  ***T=O(n), S=O(1)***

+ 利用双指针+原本的``head``指针进行迭代
+ 原本链表的头结点在反转后是尾结点，指向空，故创建一个前指针``prev``，初始化为``nullptr``
+ 再创建一个现指针``curr``，指向``head``，也就是头结点，该指针将从原链表的头遍历指尾
+ 迭代条件：``curr``指针不为空（为空代表已经将指针遍历完毕）
  + 让``head``指针指向下一个结点，为了后续移动``curr``
  + ``curr``所指向的结点的指针域改为指向``curr``的前一个结点``prev``（最开始时是``nullptr``)
  + 将``prev``移动至``curr``的位置，``curr``移动至当前``head``的位置（也就是原链表的下一个结点）

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 整个链表的反转，可以看成是头结点和后续链表整体（已经完成反转）进行反转
  + ``head->next->next = head``

+ 相邻两层递归之间的关系是头结点指针域所指向的下一层的指针域指向头结点，然后头结点指针域置空

## 动态规划

### 概述

**==本质：==**

+ 利用==历史记录==，来避免重复计算的问题，同时也需要一些==变量==来存储历史记录，一般是用==一维或者二维数组==来存储

**==求解动态规划的三大步骤：==**

1. **定义数组元素的含义**

2. **找出数组元素之间的关系式：**一般采用==归纳法==，也就是利用历史数据找找出新的元素值
3. **找到初始值**

> 在完成上述步骤后，还可以试着找下有无优化空间复杂度的方法

### 60 不同路径

**==解法1：动态规划==**		***T=O(mn), S=O(mn)***

+ 创建一个``m×n``的二维数组``dp``，每个值都代表从初始位置移动到当前位置的路径总数
+ 数组之间的关系是：``dp[i][j] = dp[i][j-1] + dp[i-1][j] ``
+ 寻找初始值，数组``dp``的首行和首列的值均为1
+ 遍历数组，求出所有值

**==解法2：动态规划（优化空间复杂度）==**  		***T=O(mn), S=O(min(m, n))***

+ 在==解法1==思路的基础上，将存储结果的数组改为一维数组``dp``，数组的长度为m和n中小的一方（假设m小）
+ 遍历该数组，初始化所有值为1
+ 将该数组滚动 n-1 次（相当于移动之后变成了一个如==解法1==中的二维数组）
  + 每滚动一次，更新``dp``中元素的值为``dp[i] += dp[i-1]``
  + 画图可得出上述的关系式（画滚动前和滚动后的数组，关系式类似==解法1==中的关系式）

### 64 最小路径和

**==解法1：动态规划==** 		***T=O(mn), S=O(mn)***

+ 创建一个与``grid``大小相同的数组``dp``，``dp[i][j]``表示移动至``grid[i][j]``的最小路径和
+ 关系：``dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j] ``
+ 初始化：数组``dp``的首行首列根据``grid``的首行首列进行初始化

**==解法2：动态规划（优化空间复杂度）==**

+ 在==解法1==的基础上，将存储结果的数组改为一个以为数组``dp``，数组的长度等于``grid``的短边
+ 后续思路***参见60 不同路径***

### 70 爬楼梯

**==解法1：动态规划==**		***T=O(n), S=O(n)***

+ 爬到第n层的最后一步，可以是从n-1层爬1层，也可以是从n-2层爬2层
+ 假设层数n和方法数量F存在 ``F(n)`` 关系，则 ``F(n)=F(n-1)+F(n-2)`` 
+ 找到上述表达式的初值，分别是n等于0、1、2时的方法数
+ 利用一个长度为``n+1``的数组，数组的索引代表==楼梯层数==，值代表==爬到当前层的方法数==，通过遍历的方法求得爬到n层有多少种方法

**==解法2：动态规划-滚动数组（对解法1的空间复杂度进行优化）==**		***T=O(n), S=O(1)***

+ 解法1中的关系式可用3位的滚动数组来实现
  + 滚动数组的第三个位置存储到达n层的方案数，前两个位置则分别存储n-2和n-1层
  + 每爬一层，后两个数据向前覆盖，第三个数据的新数据由前两层相加获得

### 72 编辑距离

**==解法：动态规划==**		***T=O(mn), S=O(mn)***

+ 假设``int n1 = word1.size()``，``int n2 = word2.size()``，则初始化一个动态规划数组``dp[n1+1][n2+1]``
  + 当两个单词中有一个长度为0时，至少需要长度1来正确的生成数组，此时就是个一维数组，代表其中一个单词为空串
+ 数组``dp``每个元素表示的是最少需要几步才能转换至==某种状态==
+ 到达``dp[i][j]``有三种出发点，出发点``dp[i-1][j]``表示增加，``dp[i][j-1]``表示删除，``dp[i-1][j-1]``表示替换
+ 则动态规划的关系为：``dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) ``
  + 补充，如果``word1[i-1]==word2[j-1]``则，此时不需要变换，也就是``dp[i][j] = dp[i-1][j-1]``
  + 如果两个单词均不为空串，那么开始对比的节点是``i=1, j=1``，此时找字符串中对应的位置就需要减1
+ 初始化：当某一个单词为空串时，变换的次数等于另一个单词的长度
  + 故``dp[0][0]=0 //两个单词均为空串``
  + ``dp[i][0] = i``，``dp[0][j] = j``

### 121 买卖股票的最佳时机

**==解法：一次遍历（动态规划演变而来）==** 	***T=O(n), S=O(1)***

+ 核心思想：每天都在考虑当天的最大收益
  + 假设在某天打算==卖出==，那么在==这天之前==的==股价最低==的那天==买入==是收益最高的做法
+ 遍历数组，记录遍历过的元素中的最低值，记录每天的最大收益，遍历结束后找出每天最大收益中的最大值

> 上述最低值并不是数组中的最低值，而是遍历过程中，遍历过的数据中的最低值（动态最低值）

### 198 打家劫舍

**==解法1：动态规划==**		***T=O(n), S=O(n)***

+ 动态规划数组为一维数组``dp[]``
+ ``dp[i]``的含义是如果有``i``间房，那么``dp[i]``就是最大收益
+ 转移方程：``dp[i] = max(dp[i-1], dp[i-2]+nums[i])``
  + 需要需要偷第 i 间的话，那么 i-1 间就不能偷
  + 如果不偷第 i 间，那么 i-1 间就可以偷
  + 在上述两个策略中选择较大者作为最佳策略

+ 初始状态，只有一间时，有``dp[0] = nums[0]``，只有两间时，``dp[1] = max(dp[1], dp[0])``

**==解法2：滚动数组（解法1的优化以降低空间复杂度）==**		***T=O(n), S=O(1)***

+ 不需要用``dp[]``来存储数据，只需要用一个大小为3的滚动数组即可

### 213 打家劫舍II

**==解法：动态规划（滚动数组）==**

+ 核心思路（转移方程等）与 ***198 打家劫舍*** 一致，唯一的区别在于
  + 因为本题头尾元素相连接，所以头尾元素只能选一个
  + 那么就分成了两种情况：
    + 盗窃第一间，最后一间不偷：1~n-1
    + 第一间不偷，盗窃最后一间：2~n
+ 再利用==两个==滚动数组，遍历一次``nums[]``数组即可求出上述两种情况对应的最大收益，大的一方就是答案

## 深度优先搜索

### 概述

**==概念：==**

+ 深度优先搜索（Depth First Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 V 的所在边都被探寻过或者搜索时节点不满足条件时，搜索将==回溯==到发现节点 V 的那条边的起始节点。整个过程反复进行直到所有节点都被访问为止。

**==分类：==**

+ 中序遍历
  + 先遍历二叉树的左子树，然后遍历二叉树的根结点，最后遍历二叉树的右子树
+ 前序遍历
  + 先遍历二叉树的根结点，然后遍历二叉树的左子树，最后遍历二叉树的右子树
+ 后序遍历
  + 先遍历二叉树的左子树，然后遍历二叉树的右子树，最后遍历二叉树的根结点

### 题型总结：岛屿问题通解

**==岛屿系列问题：==**

+ [200 岛屿数量](#200)
+ [463 岛屿的周长](#463)
+ **695 岛屿的最大面积**
+ **827 最大人工岛**

**==网格类问题的DFS遍历方法：==**

**二叉树的遍历：**二叉树的遍历有两个方向，分别是==左子树==和==右子树==，且所有节点都不会重复遍历，遇到空节点返回

**网格类的遍历：**网格可以看成是无向图，每个节点都有四个方向，分别是上下左右，有==重复遍历==的可能，==超出网格边界返回==

相比于二叉树的DFS，网格类需要解决三个问题：

+ 如何判断是否超出网格边界：==判断下标是否超出网格边界==
+ 如何判断是否重复遍历：遍历过一个岛屿节点（也就是``'1'``）后，将值改为``'2'``，代表这是遍历过的岛屿
+ 如何访问某一节点的相邻节点：二维数组的两个下标加一减一即可

**==岛屿问题DFS的框架代码：==**

```c++
void dfs(vector<vector<char>>& grid, int r, int c){
    //判断是否越界
    if(!inArea(grid, r, c)) return;
    //判断是否岛屿块
    if(grid[r][c] != '1') return;
    //将岛屿块改为已遍历过的状态
    grid[r][c] = '2';
    
    //访问周边的四个节点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

bool inArea(vector<vector<char>>& grid, int r, int c){
    return 0 <= r && r < grid.size() && 0 <= c && c < grid[0].size();
}
```

### 94 二叉树的中序遍历

**==解法1：DFS（递归）==**		***T=O(n), S=O(n)***

+ 如果当前节点不为空，访问左子树，再访问根结点，最后访问右子树
+ 左右子树的访问遵循上述规则（递归）
+ 递归的终点是当前节点为空

**==解法2：DFS（迭代）==**		***T=O(n), S=O(n)***

+ 创建一个栈用以存储访问过的父节点
+ 遍历依旧从根结点开始，但此时不需要访问根结点，而是沿着左子树一直找到叶节点
+ 遍历过程中遇到的所有节点都入栈
+ 当一个节点为空时（叶节点的左右子节点），可以利用栈顶元素访问它的父节点

> 不论是中序遍历还是前序或者后序遍历，其**迭代**实现都要：利用两个``whlie``循环实现；以及一个辅助栈

### 101 对称二叉树

**==解法1：DFS（递归）==**		***T=O(n), S=O(n)***

+ 用两个指针``q``和``p``从头结点出发，判断二叉树是否对称
+ 当``q``左移时，``p`` 右移；反之亦然
+ 移动后如果节点都不存在，则表示对称，如果只有一个存在，则表示不对称
+ 如果都存在，则判断是否相等，相等则对称（同时还要判断他们的子树是否对称，通过递归）

**==解法2：DFS（迭代）==**  	***T=O(n), S=O(n)***

+ 利用一个队列来实现递归转换为迭代，同时创建两个指针来遍历二叉树（参考解法1）
+ 初始时先将头节点入队两次，队列不为空时
  + 每次都从队头取出两个元素进行判断
    + 如果都为空，则代表对称，进入下一次判断
    + 如果只有一个为空或者值不相等，则代表不对称
  + 将取出的这两个元素的两个子节点按照正确的顺序插入队中（参考解法1）

### 104 二叉树的最大深度

**==解法：DFS（递归）==**		***T=O(n), S=O(height)***

+ 如果知道了左子树和右子树的最大深度``l``和``r``，那么二叉树的最大深度为``max(l, r) + 1 ``
+ 而左子树和右子树的最大深度可以用相同的方法计算（递归）
+ 递归在访问到空节点时退出

### 112 路径总和

**==解法：DFS（递归）==**

+ 递归函数的功能是判断当前当前节点所在路径的累加和是否等于``targetSum``
+ 该路径除了当前节点以外的部分的判别方式与上述判别方式相同（递归）

+ 套用前序遍历，访问每一个结点时，判断：
  + 如果当前节点为空，直接返回``false``（只有可能在头结点为空时出现这种状况，详见下一个条件的逻辑）
  + 如果当前节点的左右子树都为空（也就是当前节点是叶节点），那么返回``sum``和当前节点值相比较的结果
  + 每当遍历过一个节点时，``targetSum``要减去当前节点的值再传递给递归的下一级，换言之，如果当前符合题意的路径存在，那么``targetSum``到达叶节点时，等于叶节点的值

### 113 路径总和II

**==解法：DFS==**			***T=O(n^2^), S=O(n)***

+ 创建两个类成员数组，``vector<int> path``和``vector<vector<int>> allPath``，前者存储值，后者存储路径（前者）
+ 每遍历一个节点，将该节点的值放入``path``，并且``targetSum``减去当前节点的值
  + 如果该节点为叶节点并且``targetSum==0``，那么将此时的``path``放入``allPath``中（找到一条路径）
  + 如果上述条件不满足，那么继续遍历该节点的左右子树，而左右子树的遍历也遵循上述规则（递归）
+ 遍历完左右子树后从``path``中将该节点弹出

### 114 二叉树展开为链表*

**==解法1：辅助队列==**			***T=O(n), S=O(n)***

+ 前序遍历二叉树，将遍历过的节点入队
+ 遍历结束后获取队头元素，同时队头出队，将该元素左子节点置空，右子节点指向队列的下一个头
+ 直到队列为空

### 144 二叉树的前序遍历

**==解法1：递归==**				***T=O(n), S=O(n)***

+ 先访问根节点，再访问左子节点，最后访问右子节点
+ 左右子节点的访问遵循上述规则（递归）
+ 当某个节点为空时返回

**==解法2：迭代==**   		***T=O(n), S=O(n)***

+ 创建一个栈负责存储父节点
+ 创建一个``curr``指针指向``root``节点
+ 当``curr``不为空或者栈不为空时（循环）
  + 当``curr``不为空时（循环）
    + 在结果数组中加入当前``curr``的值
    + ``curr``入栈（为了后续访问其左右子节点时可以返回）
    + ``curr``移动至其左子节点处
  + 如果``curr``为空，代表上述循环结束，此时将栈顶元素赋值给``curr``
  + 栈顶元素出栈
  + ``curr``进而访问其右子节点

### <span id="200">200 岛屿数量</span>

**==解法：DFS==**		***T=O(mn), S=O(mn)***

+ 遍历数组
  + 如果数组当前元素等于``'1'``，则将该位置传入***岛屿问题DFS通用模板*** ，可以查找出一个岛屿包含的所有``'1'``
  + 每当调用一次 DFS， 则代表找到了一个岛屿

### 226 反转二叉树

**==解法：DFS（递归）==**		***T=O(n), S=O(n)***

+ 假设左子树和右子树都已经翻转完毕，则只需要交换根结点的左右子树的位置即可
+ 左子树和右子树的翻转也遵循上述规则（递归）
+ 递归在访问到空节点时直接返回

### 235 二叉搜索树的最近公共祖先

**==解法：一次遍历（利用二叉搜索树的性质）==**		***T=O(n), S=O(1)***

+ 从根结点开始遍历
  + 如果当前节点的值大于``p``和``q``的值，则当前节点移动至它的左节点
  + 如果当前节点的值小于``p``和``q``的值，则当前节点移动至它的右节点
  + 如果上述条件都不满足，则代表找到了公共祖先（和二叉搜索树的性质有关）

### 236 二叉树的最近公共祖先

**==解法：DFS（递归）==**		***T=O(n), S=O(n)***

+ 终止条件：从根结点开始遍历，如果此时``root==nullptr``或者等于``p``和``q``的其中一个，则直接返回当前的``root``
+ 递推过程：遍历左子树，返回值是``left``，遍历右子树，返回值是``right``
+ 对``left``和``right``的返回值进行判断
  + 如果==同时为空==，代表没有找到``p``和``q``，故返回``nullptr``
  + 如果==只有一个为空==，返回非空者（非空者就是公共祖先，至少包含``q``和``p``中的一个）
  + 如果==同时不为空==，代表当前节点就是公共祖先（``p``和``q``异侧）

### 337 打家劫舍III

**==解法1：后序遍历，每个节点设置加权，哈希表存储每个节点的结果==**		***T=O(n), S=O(n)***

+ 对于这棵二叉树，每个节点有两种权值，选中与不选中
  + 可以用 ***f(o)*** 表示节点 ***o*** 被选中的情况下，其子树的最大权值和
  + 用 ***g(o)*** 表示节点 ***o*** 不被选中的情况下，其子树的最大权值和
  + ***l*** 和 ***r*** 表示 ***o*** 的左右孩子
+ 当节点 ***o*** 被选中时，其左右孩子都不能被选中，故 ***f(o) = g(l) + g(r) + o.val***
+ 当节点 ***o*** 未被选中时，其左右孩子都能被选中，也可以不选中，故 ***g(o) = max{ f(l), g(l) } + max{ f(r), g(r) }***
+ 可以用一个哈希表来存储 ***f & g*** 的函数值，后续遍历二叉树可以得到每个节点的 ***f & g***

**==解法2：解法1优化空间复杂度==**		***T=O(n), S=O(n)***

+ 无论是 ***f(o) & g(o)*** ，他们的值只与 ***f(l), f(r), g(l), g(r)*** 有关，故每个节点计算后可以将节点的  ***f(o) & g(o)*** 作为一个对组返回

### 437 路径总和III

**==解法1：DFS中嵌套DFS==**			***T=O(n^2^), S=O(n)***

+ 前序遍历二叉树，对于每个节点
  + 前序遍历以当前节点为根的树，找出所有符合题意的路径

**==解法2：前缀和==**		***T=O(n), S=O(n)***

+ 前缀和的==概念==是：从根结点到当前节点的路径中所有节点的值的和
+ 创建一个成员变量哈希表，key 是前缀和，value 是这个前缀和出现的次数
+ 前序遍历二叉树，每当访问一个节点时
  + 求出到该节点的前缀和``curr``
  + 在哈希表中查找``curr-targetSum``是否存在（如果存在，则表示存在某一节点到当前节点的路径和符合条件）
  + 如果存在，则代表以该节点为终点的路径有``hashmap[curr-targerSum]``条符合条件，记此时的数量为``ret``
  + 同时，每当生成一个前缀和，都要更新哈希表
  + 递归计算==以左子树和右子树中所有节点==为==终点==的路径有几条符合条件，加至``ret``（递归函数本身的功能就是这条）
  + 当计算完成后，需要在哈希表中对当前前缀和（key）的值自减，防止重复计算

> 哈希表需要初始化``hashmap[0]=1;``，这一步是为了==保证路径以根结点为起始节点时能正确的计算结果==
>
> 比如路径``[1, 4]``且``targetSum=5``，``hashmap``中的 key 值只有两个：``1``和``5``，当在哈希表中寻找``curr-targetSum``也就是``0``时
>
> 是找不到对应的 key 值的，但实际上这条路径又是符合条件的
>
> 所以初始化``hashmap[0]=1;``可以认为是根结点有一个虚拟的前驱节点，其前缀和为``0``

### <span id="463">463 岛屿的周长</span>

**==解法1：DFS==**		***T=O(mn), S=O(mn)***

+ 本质还是参考 ***岛屿问题DFS通用模板***，如果 DFS 遍历过程中遇到==边界==或者==海洋==，则周长加一
+ DFS 中遍历过的陆地（``1``）需要改成 ``2`` ，防止重复遍历的时候重复计算

**==解法2：转换为数学问题==**		***T=O(mn), S=O(1)***

+ 因为只有一个岛屿，所以可以将问题转换为：有多少个陆地板块（``1``）相邻
  + 由数学层面易推算出：***周长 = 岛屿数量 × 4 - 相交的陆地板块对数 × 2***
+ 遍历数组，对每一个元素
  + 如果是 ``1``
    + 陆地数量加一
    + 同时判断其右边和下面等于 ``1`` 的格子有几个，每有一个 ``1`` 就代表有一对相邻的陆地板块（考虑右边界和下边界）
+ 利用公式求出岛屿周长

> 只判断每个为``1``的格子的右边和下面可以防止重复计算，也要考虑边界溢出问题

### 538 把二叉树转换为累加树

**==解法：反向中序遍历==**			***T=O(n), S=O(n)***

+ 反向中序遍历二叉搜索树即可，用一个变量来存储遍历过的所有节点的累加值

### 543 二叉树的直径

**==解法：DFS（递归）==**			***T=O(n), S=O(n)***

+ 二叉树路径的长度等于该路径经过的节点数减一，故求直径等于求经过节点数最多的路径
+ 对于一个根结点，假设其向左子树遍历经过的最多节点数为``L``，向右子树遍历经过的最多节点为``R``
  + 那么经过该根结点的最长路径的节点数为``L+R+1``
+ 定义一个递归函数求某结点最长路径的节点数``N``，函数返回该节点为根的子树的深度
+ 先递归调用左子树和右子树求出各自的深度，该节点的子树的深度则为二者中较大的一方
+ 调用过程中，记录下最长路径的节点数``L+R+1``，那么直径就是``L+R``

### 617 合并二叉树

**==解法：DFS（递归）==**			***T=O(min(m, n)), S=O(min(m, n))***

+ 假设根结点的左右子树都合并完成，则此时只需要考虑根结点的合并即可
+ 左右子树的合并遵循上述规则（递归）
+ 递归的终点是至少有一个子树为空（``root1``和``root2``）

## 广度优先搜索

### 概述

**==概念：==**BSF（Breadth First Search）是一种盲目搜索法，目的是系统地展开并检查图中的所有节点以寻找结果

+ BSF常用于解决==最短路径==问题
  + 从节点A出发，有前往节点B的路径吗
  + 从节点A出发，前往节点B最短的路径是哪条

**==基本实现：==**

