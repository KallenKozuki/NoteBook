# LeetCode_算法

## 递归

### 概述

**==实现递归的三个条件：==**

+ 大问题能拆解成两个子问题
+ 子问题的求解方式和大问题一样
+ 存在最小子问题

**==实现递归的三个步骤：==**

+ 分析问题、寻找递归：明确递归函数需要做到的功能
+ 设置边界、控制递归：明确递归的结束条件
+ 设计函数、确定参数：找到相邻的两层递归之间的关系（确定函数的关系）

**==递归的意义：==**

+ 缩小问题规模
+ 可让我们不必思考中间过程

### 21 合并两个有序链表

**==解法1：递归==**	 ***T=O(m+n), S=O(m+n)***

+ 如果两个链表中有一个为空，则返回另一个
+ 判断链表头的数据域的值，假设``list1``的较小
  + 将``list1->next``指向函数``mergeTwoLists``（递归）的返回值，同时传递形参时要传入除去表头的``list1``
    + ``mergeTwoLists``的返回值就是合并后新链表的表头

  + 递归的终点是某一个链表为空

**==解法2：迭代==**	 ***T=O(m+n), S=O(1)***

+ 创建一个虚拟头，可用任意数据初始化
+ 创建一个``curr``指针指向虚拟头，该指针表示当前正在操作的结点
+ 如果两个链表都不为空
  + 对比此时两个==链表头的值==，创建一个指向==前述比较小者指针==的指针``pp``
  + 将``curr``结点的``next``指向``pp``所指向的指针所代表的结点，并且移动``curr``至该结点
  + 利用``pp``操作对应的链表指针到下一个结点
+ 进一步将非空的链表接在``curr``后面
+ 新建一个``res``指针指向虚拟头的下一个结点（在逻辑上就是链表合并后的头结点）
+ 释放虚拟头的内存，返回``res``作为答案

> 创建``dummy``是因为不知道合并后的链表头原先属于哪个链表，用``dummy``可以方便后续操作
>
> 创建指向指针的指针``pp``是因为对两个链表所进行的操作是一样的，唯独变量名不一样
>
> 所以利用一个指向指针的指针可以方便的操作需要操作的链表（节省代码量）
>
> 本质上，``curr``指针就是为了操作当前结点的指针域，而``pp``就标示了指针域应该指向的目标结点

### 83 删除排序链表中的重复元素

**==解法1：迭代==**  	***T=O(n), S=O(1)***

+ 创建快慢指针，慢指针指向头结点，快指针指向头结点的下一个结点
+ 当快指针不为空时
  + 判断此时慢指针的数据域是否等于快指针的数据域
    + 相等：快指针移向下一个结点，慢指针的指针域指向快指针结点
    + 不等：慢指针结点等于快指针结点，快指针移向下一个结点

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 问题可以分解成头指针结点``head``和后续完成了删除操作的链表的头指针``nextHead``进行对比
  + 对比结果若相等，则``head->next = nextHead->next;``

+ 上述的后续链表的删除操作遵循同一原理


### 203 移除链表元素

**==解法1：递归==**	 ***T=O(n), S=O(n)***

+ 整个链表删除特定元素，可以分解成头结点（未判断）+后续链表（判断完成）
+ 此时判断头结点的数据域是否需要被删除
  + 需要删除则将头指针移向下一个结点（后续链表的头）
  + 否则将头结点的指针域指向后续链表

**==解法2：迭代（双指针）==**	  ***T=O(n), S=O(1)***

+ 为当前链表创建一个虚拟头，虚拟头的指针域指向当前链表的头结点
+ 创建快慢指针，慢指针指向虚拟头，快指针指向链表实际的头
+ 如果快指针不为空
  + 判断快指针结点数据域的内容
    + 删除的操作是直接让慢指针结点跳过快指针，指向快指针的下一个结点，同时快指针移动至慢指针的下一个结点
    + 如果不需要删除，则慢指针移动至快指针的位置，快指针移动至下一个结点
+ 重新指定链表头为虚拟头的下一个结点
+ 释放虚拟头的内存

### 206 反转链表

**==解法1：迭代==**	  ***T=O(n), S=O(1)***

+ 利用双指针+原本的``head``指针进行迭代
+ 原本链表的头结点在反转后是尾结点，指向空，故创建一个前指针``prev``，初始化为``nullptr``
+ 再创建一个现指针``curr``，指向``head``，也就是头结点，该指针将从原链表的头遍历指尾
+ 迭代条件：``curr``指针不为空（为空代表已经将指针遍历完毕）
  + 让``head``指针指向下一个结点，为了后续移动``curr``
  + ``curr``所指向的结点的指针域改为指向``curr``的前一个结点``prev``（最开始时是``nullptr``)
  + 将``prev``移动至``curr``的位置，``curr``移动至当前``head``的位置（也就是原链表的下一个结点）

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 整个链表的反转，可以看成是头结点和后续链表整体（已经完成反转）进行反转
  + ``head->next->next = head``

+ 相邻两层递归之间的关系是头结点指针域所指向的下一层的指针域指向头结点，然后头结点指针域置空

## 动态规划

### 概述

**==本质：==**

+ 利用==历史记录==，来避免重复计算的问题，同时也需要一些==变量==来存储历史记录，一般是用==一维或者二维数组==来存储

**==求解动态规划的三大步骤：==**

1. **定义数组元素的含义**

2. **找出数组元素之间的关系式：**一般采用==归纳法==，也就是利用历史数据找找出新的元素值
3. **找到初始值**

> 在完成上述步骤后，还可以试着找下有无优化空间复杂度的方法

### 60 不同路径

**==解法1：动态规划==**		***T=O(mn), S=O(mn)***

+ 创建一个``m×n``的二维数组``dp``，每个值都代表从初始位置移动到当前位置的路径总数
+ 数组之间的关系是：``dp[i][j] = dp[i][j-1] + dp[i-1][j] ``
+ 寻找初始值，数组``dp``的首行和首列的值均为1
+ 遍历数组，求出所有值

**==解法2：动态规划（优化空间复杂度）==**  		***T=O(mn), S=O(min(m, n))***

+ 在==解法1==思路的基础上，将存储结果的数组改为一维数组``dp``，数组的长度为m和n中小的一方（假设m小）
+ 遍历该数组，初始化所有值为1
+ 将该数组滚动 n-1 次（相当于移动之后变成了一个如==解法1==中的二维数组）
  + 每滚动一次，更新``dp``中元素的值为``dp[i] += dp[i-1]``
  + 画图可得出上述的关系式（画滚动前和滚动后的数组，关系式类似==解法1==中的关系式）

### 64 最小路径和

**==解法1：动态规划==** 		***T=O(mn), S=O(mn)***

+ 创建一个与``grid``大小相同的数组``dp``，``dp[i][j]``表示移动至``grid[i][j]``的最小路径和
+ 关系：``dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j] ``
+ 初始化：数组``dp``的首行首列根据``grid``的首行首列进行初始化

**==解法2：动态规划（优化空间复杂度）==**

+ 在==解法1==的基础上，将存储结果的数组改为一个以为数组``dp``，数组的长度等于``grid``的短边
+ 后续思路***参见60 不同路径***

### 70 爬楼梯

**==解法1：动态规划==**		***T=O(n), S=O(n)***

+ 爬到第n层的最后一步，可以是从n-1层爬1层，也可以是从n-2层爬2层
+ 假设层数n和方法数量F存在 ``F(n)`` 关系，则 ``F(n)=F(n-1)+F(n-2)`` 
+ 找到上述表达式的初值，分别是n等于0、1、2时的方法数
+ 利用一个长度为``n+1``的数组，数组的索引代表==楼梯层数==，值代表==爬到当前层的方法数==，通过遍历的方法求得爬到n层有多少种方法

**==解法2：动态规划-滚动数组（对解法1的空间复杂度进行优化）==**		***T=O(n), S=O(1)***

+ 解法1中的关系式可用3位的滚动数组来实现
  + 滚动数组的第三个位置存储到达n层的方案数，前两个位置则分别存储n-2和n-1层
  + 每爬一层，后两个数据向前覆盖，第三个数据的新数据由前两层相加获得

### 72 编辑距离

**==解法：动态规划==**		***T=O(mn), S=O(mn)***

+ 假设``int n1 = word1.size()``，``int n2 = word2.size()``，则初始化一个动态规划数组``dp[n1+1][n2+1]``
  + 当两个单词中有一个长度为0时，至少需要长度1来正确的生成数组，此时就是个一维数组，代表其中一个单词为空串
+ 数组``dp``每个元素表示的是最少需要几步才能转换至==某种状态==
+ 到达``dp[i][j]``有三种出发点，出发点``dp[i-1][j]``表示增加，``dp[i][j-1]``表示删除，``dp[i-1][j-1]``表示替换
+ 则动态规划的关系为：``dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) ``
  + 补充，如果``word1[i-1]==word2[j-1]``则，此时不需要变换，也就是``dp[i][j] = dp[i-1][j-1]``
  + 如果两个单词均不为空串，那么开始对比的节点是``i=1, j=1``，此时找字符串中对应的位置就需要减1
+ 初始化：当某一个单词为空串时，变换的次数等于另一个单词的长度
  + 故``dp[0][0]=0 //两个单词均为空串``
  + ``dp[i][0] = i``，``dp[0][j] = j``

### 121 买卖股票的最佳时机

**==解法：一次遍历（动态规划演变而来）==** 	***T=O(n), S=O(1)***

+ 核心思想：每天都在考虑当天的最大收益
  + 假设在某天打算==卖出==，那么在==这天之前==的==股价最低==的那天==买入==是收益最高的做法
+ 遍历数组，记录遍历过的元素中的最低值，记录每天的最大收益，遍历结束后找出每天最大收益中的最大值

> 上述最低值并不是数组中的最低值，而是遍历过程中，遍历过的数据中的最低值（动态最低值）

### 

