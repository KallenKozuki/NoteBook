# LeetCode_数据结构

## 重点题目

[146 LRU缓存](#146)

## 哈希表

### 1 两数之和

==**解法1：暴力枚举**== 	***T=O(n^2^), S=O(1)*** 

==**解法2：哈希表**== 	***T=O(n), S=O(n)***

+ 创建哈希表，key值存储数组中元素，value存储该元素对应的索引

+ 遍历数组

  + 如果==当前数组元素==能在哈希表中找到一个==与之相加得到目标值==的key，则返回==当前元素的索引==和哈希表==key值对应的value==

  + 如果不存在上述的目标key值，则向哈希表中添加该数组元素作为新的key值


> 为了节省时间复杂度，将遍历过的内容存储到另一个空间中，相对的提高了空间复杂度

### 13 罗马数字转整数

**==解法1：哈希表转换数字==**			***T=O(n), S=O(1)***

+ 用一个哈希表存储所有的罗马数字转换
+ 遍历字符串
  + 如果当前元素不是字符串最后一个元素，且后者比当前元素大，当前元素符号取反后加至最终结果
  + 否则直接在最终结果上加上当前元素

**==解法2：switch转换数字==**			***T=O(n), S=O(1)***

+ 与解法1思路区别仅在于用``switch``进行单个罗马数字和阿拉伯数字的转换

> 虽然时间复杂度和空间复杂度与解法1一致，但解法2效率更高

### 36 有效的数组

**==解法：哈希表==**				***T=O(1), S=O(1)***

+ 分别用三个哈希表（本题可以用二维数组）记录每个数字在它所在的行、列、盒内的出现情况

  + 二维数组的第一维索引表示的是``board[i][j]``所在的*** 行/列/盒***
  + 第二维索引表示的是``curNum``，即``board[i][j]``所表示的数字 1~9，又因索引从0开始，故``curNum-1``
  + 所有哈希表的所有值都初始化为0，表示该数字（第二维）在该行/列/盒（第一维）未出现
  + 以行为例，``row[i][curNum]``表示的是``curNum``在``board[i]``出现与否（0-未出现；1-出现）

  + 盒的索引的原理：
    + 9*9的九宫格中一共有3\*3个子九宫格（画图理解）
    + 最直接的逻辑是用一个三维数组来实现，``box[i/3][j/3][curNum]``
    + ``i/3``表示当前盒的行数，``j/3``表示当前盒的列数，``curNum``同前
    + 也可以降至二维处理，单纯用 0~8 的序号认定所有的盒
    + 画图分析可得当前盒的序号为``(i/3)*3 + j/3``，故降至二维，与行列的哈希表维数一致

+ 遍历``board``

  + 如果出现``'.'``则``continue``
  + 对于所有的数字，分别与三个哈希表进行对比如果存在（哈希表``value==1``）则数独无效
  + 若都不存在，三个哈希表相应的``value=1``

### 49 字母异位词分组

**==解法：哈希表==**

+ 创建一个哈希表，``key``为字符串（表示异位词），``value``为当前异位词的所有单词构成的数组
+ 遍历字符串数组
  + 对每一个元素``strs[i]``进行排序得``temp``，以``temp``为键值将``strs[i]``插入到哈希表对应的位置中
+ 遍历哈希表
  + 将每一个键值下对应的数组都添加到答案中

> 遍历语句``for(auto& elem: hashMap)``中，要用引用的方式来进行对``elem``的操作，可以减少空间复杂度

### 136 只出现一次的数字

**==解法1：哈希表==** 	***T=O(n), S=O(n)***

+ 遍历数组，转存至哈希表，key存数组元素，value存该元素出现的次数
+ 遍历哈希表，找到value等于1的元素

**==解法2：位运算（异或）==**		***T=O(n), S=O(1)***

+ 两个数异或运算：若这两个数相等则运算得0，不等则运算得1
+ 异或运算符合交换律和结合律
+ 异或运算符为``^``
+ 从第二位（索引等于1）遍历数组，将每个数都和数组首位进行异或运算
+ 遍历结束后返回数组首位

### 217 存在重复元素

**==解法：哈希表==** 	***T=O(n), S=O(n)***

+ 创建哈希表，遍历数组中的每一个元素
  + 若在哈希表中查找到该元素，找到则返回真
  + 找不到则将该元素插入哈希表

### 242 有效的字母异位词

**==解法1：排序后对比==**	 ***T=O(nlogn), S=O(logn), 排序导致的复杂度***

+ 两个字符串对比大小，不相同则直接返回假
+ 大小相同时对两个字符串排序，排序结果相同则返回真

**==解法2：哈希表==**	 ***T=O(n), S=O(1)***

+ 两个字符串对比大小，不相同则直接返回假
+ 创建一个哈希表（因为本题操作的是26个英文字母，故可以用一个26位的整型数组作为哈希表）
+ 遍历字符串``s``
  + 当一个字符在``s``中出现时，在数组中对应的位置自加
  + 当一个字符在``t``中出现时，在数组中对应的位置自减
+ 遍历哈希表，所有元素为0则返回真

> 字符型用整型表示的方式：``小写字符变量 - 'a'``，本质上是两者ASCII码的差值，0~25正好对应26个字母

### 350 两个数组的交集II

**==解法1：哈希表==** 	***T=O(m+n), S=O(min(m, n))***

+ ==对比两个数组的大小==，将小者转存至哈希表，key值为数组的元素，value为该元素出现的次数
  +  可以主观认为形参列表中前者（``nums1``）为小数组，若前者大，则交换形参位置递归传递

  +  ``hashmap[nums1[i]]++; //如果nums1[i]在哈希表中存在，则value自加；若不存在，则创建新的key并且value自加``

+ 遍历``nums2``（大的数组），利用哈希表的计数函数判断当前元素是否存在于哈希表中
  + 存在则将当前数组元素压入交集数组，并且哈希表对应的value值自减
  + 如果哈希表中某个value值为零，则删除该key值

**==解法2：双指针==**	 ***T=O(mlogm+nlogn), S=O(min(m, n))***

+ 两个数组排序

+ 两个指针分别指向两个数组的开头
+ 对比指针指向的值，直到某一个指针超出数组边界
  + 小的一方指针向右偏移
  + 相等则将当前值添加到交集数组

> 排序算法``sort()``的时间复杂度为***O(nlogn)***

### 383 赎金信

**==解法1：哈希表==**	   ***T=O(m+r), S=O(m)***

+ 遍历``magazine``，将==出现的字符==作为哈希表的key，==频数==作为value存入哈希表中（哈希表可用26位的整形数组）
+ 遍历``ransomNote``，在哈希表中对比当前字符的频数
  + 大于0则哈希表对应的``value``自减
  + 否则返回假

**==解法2：查找后删除==** 	***T=O(m\*r), S=O(1)***

+ 遍历``ransomNote``，在``magazine``中``find``当前字符
  + 找到则在``magazine``中``erase``该字符
  + 否则返回假

### 387 字符串中的第一个唯一字符

**==解法1：哈希表（存频数）==**	 ***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存字符出现的频数，遍历字符串一次，更新哈希表
+ 再次遍历字符串，与哈希表进行对比，当出现某个字符只出现了一次时，返回索引

**==解法2：哈希表（存索引)==** 	***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存这个字符的索引，遍历字符串
  + 若该字符第一次出现，记录字符的索引
  + 若该字符非第一次出现，将其索引值改为``-1``
+ 创建一个整型``res``存储答案，初始化为``n``
+ 遍历哈希表，对于所有``value!=-1``的字符，如果该字符索引小于``res``，则更新答案

**==解法3：哈希表配合队列==**	 ***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存索引，遍历字符串
  + 若该字符第一次出现，则存入哈希表，同时压入队列
  + 若非第一次出现，则将其索引改为-1，同时反复判断队列头
    + 若队列头不为空且队列头对应的元素在哈希表中的value值为-1，出队
+ 遍历字符串结束后，若队列不为空，则返回队列头对应元素的索引，否则返回-1

**==解法4：字符串查找函数==**	 ***T=O(n), S=O(1)***  **※最优解法※**

+ 字符串有实现查找功能的成员函数：``find()``和``rfind()``，分别是顺序查找和倒序查找
+ 遍历字符串，对所有字符而言，若顺序查找和倒序查找返回的索引相同，则代表这是第一个非重复字符

### 448 找到数组中消失的数字

**==解法1：哈希表==**		***T=O(n), S=O(n)***

+ 遍历数组，转存至哈希表，将数组元素的值作为哈希表的key，该元素出现的次数作为value
+ 遍历哈希表，找出所有出现次数为0的key

**==解法2：数组本身作为哈希表==**		***T=O(n), S=O(1)***

+ 求出数组的长度``n``
+ 遍历数组
  + 对每个元素进行减一后对``n``取余求得``x``
  + 对索引为``x``的数组元素进行``+n``的操作
+ 再次遍历数组，找出所有不大于``n``的元素的索引，将该索引加一后压入答案数组

> 思路的核心就是利用范围在[1, n]之外的数字来表达**是否存在**的含义

## 数组

### 15 三数之和

**==解法：降维+双指针==**		***T=O(n^2^), S=O(1)***

+ 特判，对于数组长度``n``，如果小于3，则直接返回``[]``
+ 对数组进行排序
+ 遍历排序后的数组
  + 如果``nums[i] > 0``，代表后续不存在三个数之和为``0``，故返回结果
  + 对于重复的元素，跳过，避免重复运算（判断法则是看``nums[i] == nums[i-1]``是否成立，成立则跳过该元素）
  + 另左指针``left = i + 1``，右指针``right = nums.size() - 1``，当``left < right``时执行循环
    + 如果``nums[i] + nums[left] + nums[right] == 0``，则执行循环，判断左右指针是否和下一位相同，去除重复解。再将左右指针移到下一个位置寻找新的解
    + 如果``nums[i] + nums[left] + nums[right] > 0``，代表右指针太大，左移
    + 如果``nums[i] + nums[left] + nums[right] < 0``，代表左指针太小，右移

### 26 删除有序数组中的重复项

**==解法：双指针==** 	***T=O(n), S=O(1)***

+ 其中快指针负责遍历数组，慢指针负责删除数组的值（快慢指针指向的值相等时删除慢指针的值）

### 48 旋转图像

**==解法1：数学推导==**		***T=O(n^2^), S=O(1)***

+ 对于矩阵中第 ***i*** 行的第 ***j*** 个元素，在旋转后，它出现在==倒数==第 ***i*** 列的第 ***j*** 个位置
+ 由数学关系推导得出，方格 ***(i, j)*** 顺时针旋转九十度后的位置为 ***(j, n-1-i)***，可得如下关系式：
  + ``matrix[j][n-1-i] = matrix[i][j]``
  + 相对的，原来的位置就有关系式``matrix[i][j] = matrix[n-1-j][i]``
+ 为了防止旋转后覆盖其他元素，利用一个``temp``变量在暂存会被覆盖的元素
+ 只需要遍历数组的四分之一即可

> 列写等式时，右值的坐标等于左值的坐标交换位置后，再修改一维的值

**==解法2：用翻转代替旋转==**		***T=O(n^2^), S=O(1)***

+ 将原数组水平翻转一次后再沿主对角线翻转一次等价于顺时针旋转90度

### 53 最大子数组和

==**解法：贪心算法**== 	***T=O(n), S=O(1)***

+ 遍历数组，对每一个元素，记录三个主要数据：
  + 当前元素==以前所有元素的和==
  + 当前元素==及其以前所有元素的和==
  + ==已出现过的所有元素和==的最大值
+ 如果当前元素==以前所有元素的和==为负数，则舍弃前面的所有元素

### 66 加一

**==解法：从末位开始找到第一个不是9的数==**		***T=O(n), S=O(1)***

+ 从数组的末位开始遍历
  + 找到第一个不是9的数
  + 将这个数加一
  + 这个数后续的所有元素置为0
+ 如果遍历后所有元素都是9，则创建一个新的数组存储答案

### 73 矩阵置零

**==解法1：标记数组==**	 ***T=O(m\*n), S=O(m+n)***

+ 已知``matrix``行数为 m 列数为 n，创建两个标志数组``row[m]``和``column[n]``，用0初始化
+ 遍历``matrix``
  + 若``matrix[i][j]==0``，则``row[i]=column[j]=1``
+ 再次遍历``matrix``
  + 如果``row[i]``和``column[j]``其中之一等于1，则``matrix[i][j]=0``

**==解法2：标记变量==** 	***T=O(m\*n), S=O(1)***

+ 创建两个标记变量``flagRow0``和``flagCol0``，初始化为0
+ 对于``matrix``的首行首列进行遍历，存在0则对应的 标记变量 置1
+ 遍历``matrix``除了首行首列以外的部分，并将首行首列作为 标记数组（参考解法1）
  + 若``matrix[i][j]==0``，则``flagRow0[i]=flagCol[j]=0``（此时0代表真，与解法1略有区别）
+ 再次遍历``matrix``除了首行首列以外的部分，利用标记数组更新``matrix[i][j]``

+ 再利用两个标记变量更新``matrix``的首行首列

> **重要！** 在解法2中，标记数组（首行首列）必须用0代表真
>
> 如果``matrix[i][j]==0``为真，则``matrix[i][0]``和``matrix[0][j]``最终也会被更新为0
>
> 但如果用1代表真，则后续利用标记数组（**首行首列**）更新``matrix``其余部分时会导致**二义性**

### 88 合并两个有序数组

**==解法1：双指针==**	 ***T=O(m+n)，S=O(m+n)***

+ 设置两个指针，分别指向两个数组的头，并创建一个大小与``nums1``相等的临时数组
+ 判断两个指针指向的值，直到某一个指针超出数组边界
  + 将==小==的一方==放入临时数组==中，同时指向这一方的指针向==下==一个位置偏移
+ 如果某个数组的指针超出边界，则直接操作另一个数组的指针，直到其超出边界
+ 最后用临时数组覆盖``nums1``

==**解法2：逆向双指针**==	***T=O(m+n), S=O(1)***

+ 因为``nums1``的末尾有预留``nums2``大小的空间，故可以从``nums1``尾部将元素从大开始排，节省了内存空间的消耗

+ 设置两个指针分别指向两个数组的尾（有效元素范围）

+ 同时设置第三个指针（可用``for``循环）负责指向``nums1``预留空间的尾

+ 判断两个指针指向的值，直到某一个指针超出边界

  + 将==大==的一方==放入==``nums1``中，同时指向这一方的指针向数组的==上==一个位置偏移

+ 如果某个数组的指针超出边界，则直接操作另一个数组的指针，直到其超出边界

### 118 杨辉三角

**==解法：暴力枚举==** 		***T=O(n^2^), S=O(1)***

+ 如果形参为0，则直接返回一个空数组
+ 初始化二维数组，行数是形参，每行的元素个数等于当前行号+1
+ 遍历数组的第一维
  + 重新指定第二维的长度的长度等于当前行号+1

  + 当前行的前后两个元素都设置为1

  + 行号大于1时（行号从0开始记），当前行的==非两端元素==等于其肩上两个元素之和

### 169 多数元素

**==解法1：随机化==**		***T=O(n), S=O(1)***

+ 无限循环，直到出现返回值

  + 随机指定一个数组内的元素为备选众数，这个概率大于二分之一

  + 遍历数组，统计备选众数出现的次数
  + 如果次数大于二分之一数组长度，则代表这个数就是众数

**==解法2：Boyer-Moore投票法==** 	***T=O(n), S=O(1)***

+ 如果将众数记为``+1``，非众数记为``-1``，将数组内全部的数加起来的结果必定大于0
+ 维护一个候选众数，且记录该众数出现的次数（初始化为0）
+ 遍历数组中的所有元素，对于每个元素
  + 如果次数为0，则将当前元素的值赋值给候选众数
  + 如果次数不为0
    + 若当前元素和候选众数相等，则次数自加
    + 若当前元素和候选众数不等，则次数自减
+ 遍历结束后，候选众数就是当前数组的众数

### 283 移动零

**==解法：双指针==**			***T=O(n), S=O(1)***

+ 如果数组长度小于2，则直接返回
+ 创建一个慢指针和快指针，初始化时都指向数组的头
+ 用快指针遍历数组
  + 当快指针遇到非0元素时，将快慢指针的值交换，然后慢指针偏移到下一个位置

> 慢指针指向的是已处理完序列的尾，快指针指向的是未处理序列的头

### 566 重塑矩阵

**==解法：矩阵映射==**	 ***T=O(m\*n), S=O(1)		此处空间复杂度不包含返回的矩阵需要的空间***

+ 一个 ***m\*n*** 的二维数组可以按行展开逐一对应映射到整数域 ***x∈[0, mn)***
  + 数组中的每一个元素 ***(i, j)*** ，按行次序映射到整数域的坐标是 ***x=i\*n+j***
  + 同理，可以按行次序将整数域的坐标映射回数组中：***i=x/n; j=x%n***
+ 故可以遍历整数域上的每一个位置，利用上述转换重塑数组

> 二维vector的初始化：``vector<vector<int>> v(r, vector<int>(c, 0));//形参列表中r是元素个数（行），后者是元素``

## 链表

### 2 两数相加

**==解法：模拟==**			***T=O(max(m, n)), S=O(1)***

+ 两个链表表示的数字都是==逆序==的，故从链表头开始每一对节点都可以直接相加
+ 同时遍历两个链表，逐位计算他们的和，同时用一个进位符``carry``来记录相加的结果是否有进位，两数相加时还应该加上进位符
+ 如果两个链表长度不同，则可以认为短的链表后续都是``0``

> 需要用到一个``head``指针来方便返回，以及一个``tail``指针方便在末尾添加
>
> 如果计算完成后进位符仍大于``0``，则需要再创建一个新节点

### 19 删除链表中的倒数第N个节点

**==解法：快慢指针+假头==**			***T=O(n), S=O(1)***

+ 在堆区创建一个假头``dummy``指向链表的``head``
+ 创建一个慢指针``slow``指向``dummy``，一个快指针``fast``指向``head``
+ 快指针先走``n``个节点，然后快指针和慢指针同步向前，直到快指针为空
+ 此时慢指针的下一个节点就是待删除的节点

### 141 环形链表

**==解法1：哈希表==** 	***T=O(n), S=O(n)***

+ 创建哈希表（set容器）存指针，遍历链表
  + 若哈希表中已存在当前结点，返回真
  + 若哈希表不存在当前结点，则将其放入哈希表
+ 如果遍历指针为空，则代表不存在环形结构

**==解法2：快慢指针（Floyd判圈算法）==** 	 ***T=O(n), S=O(1)***

+ 创建一快一慢两个指针，从链表头开始，慢指针每次移动一步，快指针每次移动两步
+ 如果快指针最终追上了慢指针，则代表链表存在环形结构
+ 否则环形结构不存在

### 142 环形链表II

**==解法1：哈希表==** 		***T=O(n), S=O(n)***

+ 创建哈希表存储每一个节点，遍历链表
  + 在哈希表中查找该节点，找到则返回该节点
  + 找不到则将该节点插入哈希表中
+ 如果遍历指针为空，则代表不存在环形结构

**==解法2：快慢指针+辅助指针==**		***T=O(n), S=O(1)***

+ 创建一个慢指针``slow``和一个快指针``fast``，都指向链表的头部``head``
+ 如果``fast && fast->next``不为空
  + 则``fast``走两步，``slow``走一步 ----- ①
+ 如果``fast && fast->next``为空则代表环形结构不存在
+ 如果两个指针相遇，假设链表非环的部分长度为 a，两个指针在环内距离入环节点的距离为 b，且环剩余的长度为 c
  + 假设此时``fast``在环内走了完整的 n 圈，则``fast``走过的距离为 ***a + n(b  + c) + b = a + (n + 1)b + nc***
  + ``slow``指针入环后第一次与``fast``相遇时，走过的距离为 ***a + b*** ，  由 ① 可得 ***a + (n + 1)b + nc = 2(a + b)***
  + 整理可得 ***a = c + (n - 1)(b + c)*** ，所以从==相遇点向前走到入环点再走 ***(n - 1)*** 圈的距离等于从头结点走到入环点的距离
+ 再设置一个指针``ret``指向``head``，和此时的``slow``指针一起每次向前走一步，二者相遇的点就是入环点

### <span id="146">146 LRU缓存</span>

**==解法：哈希表+双向链表==**

+ 双向链表按照被使用的顺序存储了键对值，靠近头部的是最近被使用过的，靠近尾部的是久未使用的
+ 哈希表则可以通过``key``直接访问双向链表的节点，节省了遍历遍历查找某一个节点的开支
+ 进行``put``和``get``操作时，先通过哈希表找到对应的节点，然后再操作该节点，并将其移动至链表头，此操作符合 ***O(1)*** 的时间要求
+ 对于``get``操作
  + 如果``key``在哈希表中不存在，则直接返回``-1``
  + 如果存在，则将``key``对应的节点移动至链表头，然后返回该节点的值
+ 对于``put``操作
  + 如果``key``在哈希表中存在，则先通过哈希表定位节点，然后修改该节点的值，最后将该节点移动至链表头
  + 如果``key``在哈希表中不存在
    + 根据``key``和``value``创建一个新的节点，将其添加到哈希表和链表头，同时``size++``
    + 如果``size > capacity``
      + 删除链表的尾部节点，同时取得该节点（前述的删除只是逻辑上的删除，并非内存上的删除）
      + 在哈希表中删除该节点对应的``key``，并且释放该节点的内存，最后``size--``

> 可以给链表添加一个**伪头部**和**伪尾部**，方便后续的操作
>
> 为了满足上述``put``和``get``操作，还需要四个辅助函数：``addtoHead``，``removeNode``，``movetoHead``，``removeTail``

### 160 相交链表

**==解法1：无序哈希集合==**		***T=O(n), S=O(n)***

+ 遍历链表A，将每个结点放入一个无序哈希集合中
+ 遍历链表B，在哈希集合中查找链表B的当前结点，找到则返回当前结点
+ 遍历结束后若没找到

**==解法2：双指针==**		***T=O(n), S=O(1)***

+ 假设链表A不相交部分长度为a，链表B不相交部分长度为b，二者相交部分长度为c
+ 初始化两个指针，分别指向链表A和B的头结点
+ 同步移动两个指针，如果有一方移动到末尾，则下一个位置是另一条链表的头
  + 一直移动到两个指针指向同一个结点，此结点就是相交的结点
  + 如果两个指针同时为空，则代表这两条链表不相交

> **相交的情况：**如若a = b，那么两个指针会同时到达相交的结点
>
> 若a != b，那么A的指针第二次到达结点移动的距离是a+c+b，指针B移动过的距离是b+c+a，此时必然同时到达交点
>
> **不相交的情况：**不相交时，A和B的指针都会走过a+b的距离，同时到达链表的末尾

### 237 删除链表中的节点

**==解法：和下一个节点交换后删除==**		***T=O(1), S=O(1)***

+ 将需要删除的节点值修改为其下一个节点的值
+ 删除下一个节点

## 字符串

### 171 Excel表序列号

**==解法：进制转换==**		***T=O(n), S=O(1)***

+ 本质就是将26进制数转换成十进制数
+ 可以从字符串的尾部开始遍历，同时设置一个加权变量，这样可以不试用``pow()``函数，节省较多的内存空间

### 344 反转字符串

**==解法：双指针==**	  ***T=O(n), S=O(1)***

+ 假设数组长度为``n``，对数组元素``s[i]``，其总是和``s[n-1-i]``交换
+ 遍历数组的前半（``i<s.size()/2``即可），将其与后半交换

### 445 两数相加II

**==解法：辅助栈==**		***T=O(max(m, n)), S=O(m+n)***

+ 利用两个栈分别存储两个链表的节点值，根据栈的特性，栈顶元素就是链表的末尾元素
+ 创建一个伪头部节点``ret``
+ 循环条件``while(!s1.empty() || !s2.empty() || carry)``
  + 如果某个栈为空，则代表这个栈的加数为``0``
  + 取得栈顶元素后，栈顶元素出栈
  + 计算所需的值，创建新的节点``curr``，且``curr``的下一个节点指向``ret``，然后再将``curr``的值赋值给``ret``

## 栈

### 单调栈类型题

[739 每日温度](#739)

[84 柱状图中最大的矩形](#84)

### 20 有效的括号

**==解法：栈判断==** 	***T=O(n), S=O(n)***

+ 创建一个``char``类型的栈

+ 遍历字符串，对每一个字符
  + 若此时栈为空，则字符入栈
  + 若栈不为空，则判断==栈顶的括号==是否能与==当前字符==组成一对完整的括号
    + 能则栈顶元素出栈
    + 不能则当前元素入栈
+ 遍历结束后若栈为空则代表括号字符串有效，否则无效

### <span id=84>84 柱状图中最大的矩形</span>

**==解法：单调栈+哨兵==**			***T=O(n), S=O(n)***

+ 思路简述：利用一个单调递增的栈来寻找最大矩形
  + 以一个柱子`a`的高度构成的最大的矩形，取决于其宽度，而宽度取决于左右边界
  + 如果左右边界的柱子高度都小于`a`的高度，那么==完全包含==`a`的==最大矩形==唯一确定
+ 遍历数组
  + 循环判断：如果即将入栈的元素小于栈内的元素（找到了栈顶柱子的右边界）
    + 获取栈顶元素的下标`index`，同时弹栈
    + 弹栈后的栈顶元素就是柱子`index`的左边界
    + 此时==完全包含==柱子`index`的矩形高等于`index`的高，宽等于左右边界下标的差再减1（简单数学分析）
    + 求出`index`的最大矩形，更新答案
  + 上述循环结束后，右边界入栈
+ 在开始遍历之前，可以给数组前后两短各加入一个高度为`0`的元素，成为==哨兵==元素
  + 如果不加入哨兵元素，栈处理时有两个问题
    + 最后一个数组元素入栈后，无法找到他的右边界
    + 无法找到最低柱子的左边界
  + 加入哨兵元素后，上述两个问题都解决了（等同于加入了两个边界）

### 155 最小栈

**==解法1：栈存对组（不需要辅助栈）==**		***T=O(1), S=O(n)***

+ 栈内插入的是对组，对组存储的是==值==和==插入该值后栈内的最小值==
+ 对组是一个整体，同时入栈出栈，故可以在栈顶访问到当前的==值==和==最小值==（依托的是栈FILO的特性）

**==解法2：辅助栈==**			***T=O(1), S=O(n)***

+ 用一个辅助栈来存储最小值，与存值的栈同步进出，思路同解法1，但只是把对组的数据拆成两个栈

### 232 用栈实现队列

**==解法：一个栈负责入队，另一个栈负责出队==**		

+ 类内设置两个成员变量，栈1和栈2，其中栈1负责入队，栈2负责出队
+ 创建一个成员函数，负责将栈1的元素反转至栈2
+ 入队操作时，直接将元素压入栈1即可	     ***T=O(1), S=O(n)***
+ 出队和取头操作时，==当且仅当栈2为空==则将栈1==反转==至栈2，然后直接操作栈2顶的元素        ***T=O(1), S=O(1)***
+ 判空则需要栈1栈2同时为空         ***T=O(1), S=O(1)***

### 496 下一个更大元素I

**==解法：单调栈+哈希表==**

+ 利用单调递减栈预处理`nums2`，用哈希表保存每一个`nums2[i]`的下一个更大元素
+ 如果预处理后栈不为空，则弹出所有元素，并使其哈希表的`value=-1`
+ 遍历`nums1`，在哈希表中查找，并将结果添加至答案

### <span id=739>739 每日温度</span>

**==解法：单调栈==**		  ***T=O(n), S=O(n)***

+ 创建一个单调栈，存放数组的下标，创建一个大小与原数组相同的答案数组，用0初始化
+ 遍历数组
  + 如果栈顶下标在数组中的值小于即将进栈的元素
    + 将栈顶下标与即将进栈元素的下标的差值存到答案中，同时栈顶元素出栈
  + 否则直接入栈

## 树

### 108  将有序数组转换成二叉搜索树

==**解法：中序遍历，总是用数组中间偏左的元素作为根结点**==			***T=O(n), S=O(logn)***

+ 因为二叉搜索树的中序遍历就是升序，和给定数组的排列一致
+ 故总是选用数组中间偏左的元素作为根结点，利用递归方法创建所有的节点
+ 递归的终止条件是数组的范围已经为空

## 位运算

### 190 颠倒二进制位#

**==解法1：逐位颠倒==**			***T=O(logn), S=O(1)***

+ 将``n``视为一个长32的二进制串，从低位往高位逐位枚举，将其结果添加至答案``ret``中
+ 每枚举一位，就将``n``右移一位，当前n的最低位就是我们当前枚举的比特位，且当``n==0``时可以结束循环

### 191 位1的个数

**==解法：Brain Kernighan算法==**		***T=O(logn), S=O(1)***

+ ``num = num&(num-1);``可以将``num``对应二进制数的最后一个``1``变成``0``
+ 计算上述步骤重复了多少次

### 338 比特位计算

**==解法1：短除法==**			***T=O(n), S=O(1)***

+ 遍历``[0, n]``范围内的所有整数，对每个数
  + 对``2``取模可得当前整数转换为二进制后的最后一位
  + 当前整数自除``2``再重复上述步骤可求得==二进制的倒数第二位==
  + 直到自除后等于``0``，运算下一个数

**==解法2：Brain Kernighan算法==**			***T=O(n), S=O(1)***

+ 遍历[0, n]范围内的所有整数，对每个数``num``
  + ``num = num&(num-1);``可以将num对应二进制数的最后一个``1``变成``0``
  + 计算上述步骤计算了多少次

### 461 汉明距离

**==解法1：逐位右移比较==**  	***T=O(logC), S=O(1)***

+ 如果``x | y``不为0时
  + 比较二者的最后一位，不同则计数加一
  + 二者都向右移动一位

**==解法2：Brain Kernighan算法==**		***T=O(logC), S=O(1)***

+ ``x ^ y``可以将两个变量中所有不同的位置都改为``1``，相同的位置都改为``0``
+ 利用 BK 算法求出``x ^ y``中``1``的个数
