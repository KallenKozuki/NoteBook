# LeetCode_Easy

## 数据结构

### A. 数组

#### 1 两数之和

==**解法1：暴力枚举**== 	***T=O(n^2^), S=O(1)*** 

==**解法2：哈希表**== 	***T=O(n), S=O(n)***

+ 创建哈希表，key值存储数组中元素，value存储该元素对应的索引

+ 遍历数组

  + 如果==当前数组元素==能在哈希表中找到一个==与之相加得到目标值==的key，则返回==当前元素的索引==和哈希表==key值对应的value==

  + 如果不存在上述的目标key值，则向哈希表中添加该数组元素作为新的key值


> 为了节省时间复杂度，将遍历过的内容存储到另一个空间中，相对的提高了空间复杂度

#### 26 删除有序数组中的重复项

**==解法：双指针==** 	***T=O(n), S=O(1)***

+ 其中快指针负责遍历数组，慢指针负责删除数组的值（快慢指针指向的值相等时删除慢指针的值）

#### 53 最大子数组和

==**解法：贪心算法**== 	***T=O(n), S=O(1)***

+ 遍历数组，对每一个元素，记录三个主要数据：
  + 当前元素==以前所有元素的和==
  + 当前元素==及其以前所有元素的和==
  + ==已出现过的所有元素和==的最大值
+ 如果当前元素==以前所有元素的和==为负数，则舍弃前面的所有元素

#### 88 合并两个有序数组

**==解法1：双指针==**	 ***T=O(m+n)，S=O(m+n)***

+ 设置两个指针，分别指向两个数组的头，并创建一个大小与``nums1``相等的临时数组
+ 判断两个指针指向的值，直到某一个指针超出数组边界
  + 将==小==的一方==放入临时数组==中，同时指向这一方的指针向==下==一个位置偏移
+ 如果某个数组的指针超出边界，则直接操作另一个数组的指针，直到其超出边界
+ 最后用临时数组覆盖``nums1``

==**解法2：逆向双指针**==	***T=O(m+n), S=O(1)***

+ 因为``nums1``的末尾有预留``nums2``大小的空间，故可以从``nums1``尾部将元素从大开始排，节省了内存空间的消耗

+ 设置两个指针分别指向两个数组的尾（有效元素范围）

+ 同时设置第三个指针（可用``for``循环）负责指向``nums1``预留空间的尾

+ 判断两个指针指向的值，直到某一个指针超出边界

  + 将==大==的一方==放入==``nums1``中，同时指向这一方的指针向数组的==上==一个位置偏移

+ 如果某个数组的指针超出边界，则直接操作另一个数组的指针，直到其超出边界

#### 118 杨辉三角

**==解法：暴力枚举==** 		***T=O(n^2^), S=O(1)***

+ 如果形参为0，则直接返回一个空数组
+ 初始化二维数组，行数是形参，每行的元素个数等于当前行号+1
+ 遍历数组的第一维
  + 重新指定第二维的长度的长度等于当前行号+1

  + 当前行的前后两个元素都设置为1

  + 行号大于1时（行号从0开始记），当前行的==非两端元素==等于其肩上两个元素之和


#### 121 买卖股票的最佳时机

**==解法：动态规划==** 	***T=O(n), S=O(1)***

+ 核心思想：每天都在考虑当天的最大收益
  + 假设在某天打算==卖出==，那么在==这天之前==的==股价最低==的那天==买入==是收益最高的做法
+ 遍历数组，记录遍历过的元素中的最低值，记录每天的最大收益，遍历结束后找出每天最大收益中的最大值

> 上述最低值并不是数组中的最低值，而是遍历过程中，遍历过的数据中的最低值（动态最低值）

#### 136 只出现一次的数字

**==解法1：哈希表==** 	***T=O(n), S=O(n)***

+ 遍历数组，转存至哈希表，key存数组元素，value存该元素出现的次数
+ 遍历哈希表，找到value等于1的元素

**==解法2：位运算（异或）==**		***T=O(n), S=O(1)***

+ 两个数异或运算：若这两个数相等则运算得0，不等则运算得1
+ 异或运算符合交换律和结合律
+ 异或运算符为``^``
+ 从第二位（索引等于1）遍历数组，将每个数都和数组首位进行异或运算
+ 遍历结束后返回数组首位

#### 169 多数元素

**==解法1：随机化==**		***T=O(n), S=O(1)***

+ 无限循环，直到出现返回值

  + 随机指定一个数组内的元素为备选众数，这个概率大于二分之一

  + 遍历数组，统计备选众数出现的次数
  + 如果次数大于二分之一数组长度，则代表这个数就是众数

**==解法2：Boyer-Moore投票法==** 	***T=O(n), S=O(1)***

+ 如果将众数记为``+1``，非众数记为``-1``，将数组内全部的数加起来的结果必定大于0
+ 维护一个候选众数，且记录该众数出现的次数（初始化为0）
+ 遍历数组中的所有元素，对于每个元素
  + 如果次数为0，则将当前元素的值赋值给候选众数
  + 如果次数不为0
    + 若当前元素和候选众数相等，则次数自加
    + 若当前元素和候选众数不等，则次数自减
+ 遍历结束后，候选众数就是当前数组的众数

#### 217 存在重复元素

**==解法：哈希表==** 	***T=O(n), S=O(n)***

+ 创建哈希表，遍历数组中的每一个元素
  + 若在哈希表中查找到该元素，找到则返回真
  + 找不到则将该元素插入哈希表

#### 283 移动零

**==解法：双指针==**			***T=O(n), S=O(1)***

+ 如果数组长度小于2，则直接返回
+ 创建一个慢指针和快指针，初始化时都指向数组的头
+ 用快指针遍历数组
  + 当快指针遇到非0元素时，将快慢指针的值交换，然后慢指针偏移到下一个位置

> 慢指针指向的是已处理完序列的尾，快指针指向的是未处理序列的头

#### 350 两个数组的交集II

**==解法1：哈希表==** 	***T=O(m+n), S=O(min(m, n))***

+ ==对比两个数组的大小==，将小者转存至哈希表，key值为数组的元素，value为该元素出现的次数
  +  可以主观认为形参列表中前者（``nums1``）为小数组，若前者大，则交换形参位置递归传递
  
  + ``hashmap[nums1[i]]++; //如果nums1[i]在哈希表中存在，则value自加；若不存在，则创建新的key并且value自加``
  
+ 遍历``nums2``（大的数组），利用哈希表的计数函数判断当前元素是否存在于哈希表中
  + 存在则将当前数组元素压入交集数组，并且哈希表对应的value值自减
  + 如果哈希表中某个value值为零，则删除该key值

**==解法2：双指针==**	 ***T=O(mlogm+nlogn), S=O(min(m, n))***

+ 两个数组排序

+ 两个指针分别指向两个数组的开头
+ 对比指针指向的值，直到某一个指针超出数组边界
  + 小的一方指针向右偏移
  + 相等则将当前值添加到交集数组

> 排序算法``sort()``的时间复杂度为***O(nlogn)***

#### 448 找到数组中消失的数字

**==解法1：哈希表==**		***T=O(n), S=O(n)***

+ 遍历数组，转存至哈希表，将数组元素的值作为哈希表的key，该元素出现的次数作为value
+ 遍历哈希表，找出所有出现次数为0的key

**==解法2：数组本身作为哈希表==**		***T=O(n), S=O(1)***

+ 求出数组的长度``n``
+ 遍历数组
  + 对每个元素进行减一后对``n``取余求得``x``
  + 对索引为``x``的数组元素进行``+n``的操作
+ 再次遍历数组，找出所有不大于``n``的元素的索引，将该索引加一后压入答案数组

> 思路的核心就是利用范围在[1, n]之外的数字来表达**是否存在**的含义

#### 566 重塑矩阵

**==解法：矩阵映射==**	 ***T=O(m\*n), S=O(1)		此处空间复杂度不包含返回的矩阵需要的空间***

+ 一个 ***m\*n*** 的二维数组可以按行展开逐一对应映射到整数域 ***x∈[0, mn)***
  + 数组中的每一个元素 ***(i, j)*** ，按行次序映射到整数域的坐标是 ***x=i\*n+j***
  + 同理，可以按行次序将整数域的坐标映射回数组中：***i=x/n; j=x%n***
+ 故可以遍历整数域上的每一个位置，利用上述转换重塑数组

> 二维vector的初始化：``vector<vector<int>> v(r, vector<int>(c, 0));//形参列表中r是元素个数（行），后者是元素``

### B.字符串

#### 242 有效的字母异位词

**==解法1：排序后对比==**	 ***T=O(nlogn), S=O(logn), 排序导致的复杂度***

+ 两个字符串对比大小，不相同则直接返回假
+ 大小相同时对两个字符串排序，排序结果相同则返回真

**==解法2：哈希表==**	 ***T=O(n), S=O(1)***

+ 两个字符串对比大小，不相同则直接返回假
+ 创建一个哈希表（因为本题操作的是26个英文字母，故可以用一个26位的整型数组作为哈希表）
+ 遍历字符串``s``
  + 当一个字符在``s``中出现时，在数组中对应的位置自加
  + 当一个字符在``t``中出现时，在数组中对应的位置自减
+ 遍历哈希表，所有元素为0则返回真

> 字符型用整型表示的方式：``小写字符变量 - 'a'``，本质上是两者ASCII码的差值，0~25正好对应26个字母

#### 344 反转字符串

**==解法：双指针==**	  ***T=O(n), S=O(1)***

+ 假设数组长度为``n``，对数组元素``s[i]``，其总是和``s[n-1-i]``交换
+ 遍历数组的前半（``i<s.size()/2``即可），将其与后半交换

#### 383 赎金信

**==解法1：哈希表==**	   ***T=O(m+r), S=O(m)***

+ 遍历``magazine``，将==出现的字符==作为哈希表的key，==频数==作为value存入哈希表中（哈希表可用26位的整形数组）
+ 遍历``ransomNote``，在哈希表中对比当前字符的频数
  + 大于0则哈希表对应的``value``自减
  + 否则返回假

**==解法2：查找后删除==** 	***T=O(m\*r), S=O(1)***

+ 遍历``ransomNote``，在``magazine``中``find``当前字符
  + 找到则在``magazine``中``erase``该字符
  + 否则返回假

#### 387 字符串中的第一个唯一字符

**==解法1：哈希表（存频数）==**	 ***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存字符出现的频数，遍历字符串一次，更新哈希表
+ 再次遍历字符串，与哈希表进行对比，当出现某个字符只出现了一次时，返回索引

**==解法2：哈希表（存索引)==** 	***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存这个字符的索引，遍历字符串
  + 若该字符第一次出现，记录字符的索引
  + 若该字符非第一次出现，将其索引值改为``-1``
+ 创建一个整型``res``存储答案，初始化为``n``
+ 遍历哈希表，对于所有``value!=-1``的字符，如果该字符索引小于``res``，则更新答案

**==解法3：哈希表配合队列==**	 ***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存索引，遍历字符串
  + 若该字符第一次出现，则存入哈希表，同时压入队列
  + 若非第一次出现，则将其索引改为-1，同时反复判断队列头
    + 若队列头不为空且队列头对应的元素在哈希表中的value值为-1，出队
+ 遍历字符串结束后，若队列不为空，则返回队列头对应元素的索引，否则返回-1

**==解法4：字符串查找函数==**	 ***T=O(n), S=O(1)***  **※最优解法※**

+ 字符串有实现查找功能的成员函数：``find()``和``rfind()``，分别是顺序查找和倒序查找
+ 遍历字符串，对所有字符而言，若顺序查找和倒序查找返回的索引相同，则代表这是第一个非重复字符

### C. 链表

#### 21 合并两个有序链表

**==解法1：递归==**	 ***T=O(m+n), S=O(m+n)***

+ 如果两个链表中有一个为空，则返回另一个
+ 判断链表头的数据域的值，假设``list1``的较小
  + 将``list1->next``指向函数``mergeTwoLists``（递归）的返回值，同时传递形参时要传入除去表头的``list1``
    + ``mergeTwoLists``的返回值就是合并后新链表的表头
  
  + 递归的终点是某一个链表为空

**==解法2：迭代==**	 ***T=O(m+n), S=O(1)***

+ 创建一个虚拟头，可用任意数据初始化
+ 创建一个``curr``指针指向虚拟头，该指针表示当前正在操作的结点
+ 如果两个链表都不为空
  + 对比此时两个==链表头的值==，创建一个指向==前述比较小者指针==的指针``pp``
  + 将``curr``结点的``next``指向``pp``所指向的指针所代表的结点，并且移动``curr``至该结点
  + 利用``pp``操作对应的链表指针到下一个结点
+ 进一步将非空的链表接在``curr``后面
+ 新建一个``res``指针指向虚拟头的下一个结点（在逻辑上就是链表合并后的头结点）
+ 释放虚拟头的内存，返回``res``作为答案

> 创建``dummy``是因为不知道合并后的链表头原先属于哪个链表，用``dummy``可以方便后续操作
>
> 创建指向指针的指针``pp``是因为对两个链表所进行的操作是一样的，唯独变量名不一样
>
> 所以利用一个指向指针的指针可以方便的操作需要操作的链表（节省代码量）
>
> 本质上，``curr``指针就是为了操作当前结点的指针域，而``pp``就标示了指针域应该指向的目标结点

#### 141 环形链表

**==解法1：哈希表==** 	***T=O(n), S=O(n)***

+ 创建哈希表（set容器）存指针，遍历链表
  + 若哈希表中已存在当前结点，返回真
  + 若哈希表不存在当前结点，则将其放入哈希表
+ 遍历结束后代表不存在环形结构

**==解法2：快慢指针（Floyd判圈算法）==** 	 ***T=O(n), S=O(1)***

+ 创建一快一慢两个指针，从链表头开始，慢指针每次移动一步，快指针每次移动两步
+ 如果快指针最终追上了慢指针，则代表链表存在环形结构
+ 否则环形结构不存在

#### 83 删除排序链表中的重复元素

**==解法1：迭代==**  	***T=O(n), S=O(1)***

+ 创建快慢指针，慢指针指向头结点，快指针指向头结点的下一个结点
+ 当快指针不为空时
  + 判断此时慢指针的数据域是否等于快指针的数据域
    + 相等：快指针移向下一个结点，慢指针的指针域指向快指针结点
    + 不等：慢指针结点等于快指针结点，快指针移向下一个结点

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 问题可以分解成头指针结点``head``和后续完成了删除操作的链表的头指针``nextHead``进行对比
  + 对比结果若相等，则``head->next = nextHead->next;``

+ 上述的后续链表的删除操作遵循同一原理

#### 160 相交链表

**==解法1：无序哈希集合==**		***T=O(n), S=O(n)***

+ 遍历链表A，将每个结点放入一个无序哈希集合中
+ 遍历链表B，在哈希集合中查找链表B的当前结点，找到则返回当前结点
+ 遍历结束后若没找到

**==解法2：双指针==**		***T=O(n), S=O(1)***

+ 假设链表A不相交部分长度为a，链表B不相交部分长度为b，二者相交部分长度为c
+ 初始化两个指针，分别指向链表A和B的头结点
+ 同步移动两个指针，如果有一方移动到末尾，则下一个位置是另一条链表的头
  + 一直移动到两个指针指向同一个结点，此结点就是相交的结点
  + 如果两个指针同时为空，则代表这两条链表不相交

> **相交的情况：**如若a = b，那么两个指针会同时到达相交的结点
>
> 若a != b，那么A的指针第二次到达结点移动的距离是a+c+b，指针B移动过的距离是b+c+a，此时必然同时到达交点
>
> **不相交的情况：**不相交时，A和B的指针都会走过a+b的距离，同时到达链表的末尾

#### 203 移除链表元素

**==解法1：递归==**	 ***T=O(n), S=O(n)***

+ 整个链表删除特定元素，可以分解成头结点（未判断）+后续链表（判断完成）
+ 此时判断头结点的数据域是否需要被删除
  + 需要删除则将头指针移向下一个结点（后续链表的头）
  + 否则将头结点的指针域指向后续链表

**==解法2：迭代（双指针）==**	  ***T=O(n), S=O(1)***

+ 为当前链表创建一个虚拟头，虚拟头的指针域指向当前链表的头结点
+ 创建快慢指针，慢指针指向虚拟头，快指针指向链表实际的头
+ 如果快指针不为空
  + 判断快指针结点数据域的内容
    + 删除的操作是直接让慢指针结点跳过快指针，指向快指针的下一个结点，同时快指针移动至慢指针的下一个结点
    + 如果不需要删除，则慢指针移动至快指针的位置，快指针移动至下一个结点
+ 重新指定链表头为虚拟头的下一个结点
+ 释放虚拟头的内存

#### 206 反转链表

**==解法1：迭代==**	  ***T=O(n), S=O(1)***

+ 利用双指针+原本的``head``指针进行迭代
+ 原本链表的头结点在反转后是尾结点，指向空，故创建一个前指针``prev``，初始化为``nullptr``
+ 再创建一个现指针``curr``，指向``head``，也就是头结点，该指针将从原链表的头遍历指尾
+ 迭代条件：``curr``指针不为空（为空代表已经将指针遍历完毕）
  + 让``head``指针指向下一个结点，为了后续移动``curr``
  + ``curr``所指向的结点的指针域改为指向``curr``的前一个结点``prev``（最开始时是``nullptr``)
  + 将``prev``移动至``curr``的位置，``curr``移动至当前``head``的位置（也就是原链表的下一个结点）

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 整个链表的反转，可以看成是头结点和后续链表整体（已经完成反转）进行反转
  + ``head->next->next = head``

+ 相邻两层递归之间的关系是头结点指针域所指向的下一层的指针域指向头结点，然后头结点指针域置空

#### 234 回文链表

**==解法1：栈==**	 ***T=O(n), S=O(n)***

+ 链表数据从头开始压入栈
+ 再次遍历链表，判断栈顶是否与当前链表结点的数据域相等，相等则出栈
+ 遍历后如果栈为空，则代表这是回文链表

**==解法2：数组+双指针==**	 ***T=O(n), S=O(n)***

+ 遍历链表存入数组，利用双指针判断数组是否回文

**==解法3（最优解法）：快慢指针求中点+反转（用迭代算法啊）+遍历==**

+ 详情参考 ***剑指Offer 02.06.***

### D. 栈

#### 20 有效的括号

**==解法：栈判断==** 	***T=O(n), S=O(n)***

+ 创建一个``char``类型的栈

+ 遍历字符串，对每一个字符
  + 若此时栈为空，则字符入栈
  + 若栈不为空，则判断==栈顶的括号==是否能与==当前字符==组成一对完整的括号
    + 能则栈顶元素出栈
    + 不能则当前元素入栈
+ 遍历结束后若栈为空则代表括号字符串有效，否则无效

#### 155 最小栈

**==解法1：栈存对组（不需要辅助栈）==**		***T=O(1), S=O(n)***

+ 栈内插入的是对组，对组存储的是==值==和==插入该值后栈内的最小值==
+ 对组是一个整体，同时入栈出栈，故可以在栈顶访问到当前的==值==和==最小值==（依托的是栈FILO的特性）

**==解法2：辅助栈==**			***T=O(1), S=O(n)***

+ 用一个辅助栈来存储最小值，与存值的栈同步进出，思路同解法1，但只是把对组的数据拆成两个栈

#### 232 用栈实现队列

**==解法：一个栈负责入队，另一个栈负责出队==**		

+ 类内设置两个成员变量，栈1和栈2，其中栈1负责入队，栈2负责出队
+ 创建一个成员函数，负责将栈1的元素反转至栈2
+ 入队操作时，直接将元素压入栈1即可	     ***T=O(1), S=O(n)***
+ 出队和取头操作时，==当且仅当栈2为空==则将栈1==反转==至栈2，然后直接操作栈2顶的元素        ***T=O(1), S=O(1)***
+ 判空则需要栈1栈2同时为空         ***T=O(1), S=O(1)***

## E. 位运算

#### 461 汉明距离

**==解法：转换为二进制后诸位判断==**  	***T=O(1), S=O(1)***

+ 对2取模可得当前整数转换为二进制后的最后一位
+ 当前整数自除2在重复上述步骤可求得==二进制的倒数第二位==

> 本质就是短除法

## 算法

### A. 动态规划

#### 70 爬楼梯

**==解法：滚动数组==**		***T=O(n), S=O(1)***

+ 爬到第n层的最后一步，可以是从n-1层爬1层，也可以是从n-2层爬2层
+ 假设层数n和方法数量F存在 ``F(n)`` 关系，则 ``F(n)=F(n-1)+F(n-2)`` ，转换成了一个递归问题
+ 而上述函数的形式，就是斐波那契数列的基本定义，故可以用3位的滚动数组来实现
  + 滚动数组的第三个位置存储到达n层的方案数，前两个位置则分别存储n-2和n-1层
  + 每爬一层，后两个数据向前覆盖，第三个数据的新数据由前两层相加获得

