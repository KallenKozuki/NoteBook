# LeetCode_Easy

## 数据结构

### A. 数组

#### 1 两数之和

==**解法1：暴力枚举**== 	***T=O(n^2^), S=O(1)*** 

==**解法2：哈希表**== 	***T=O(n), S=O(n)***

+ 创建哈希表，key值存储数组中元素，value存储该元素对应的索引

+ 遍历数组

  + 如果==当前数组元素==能在哈希表中找到一个==与之相加得到目标值==的key，则返回==当前元素的索引==和哈希表==key值对应的value==

  + 如果不存在上述的目标key值，则向哈希表中添加该数组元素作为新的key值


> 为了节省时间复杂度，将遍历过的内容存储到另一个空间中，相对的提高了空间复杂度

#### 26 删除有序数组中的重复项

**==解法：双指针==** 	***T=O(n), S=O(1)***

+ 其中快指针负责遍历数组，慢指针负责删除数组的值（快慢指针指向的值相等时删除慢指针的值）

#### 53 最大子数组和

==**解法：贪心算法**== 	***T=O(n), S=O(1)***

+ 遍历数组，对每一个元素，记录三个主要数据：
  + 当前元素==以前所有元素的和==
  + 当前元素==及其以前所有元素的和==
  + ==已出现过的所有元素和==的最大值
+ 如果当前元素==以前所有元素的和==为负数，则舍弃前面的所有元素

#### 88 合并两个有序数组

**==解法1：双指针==**	 ***T=O(m+n)，S=O(m+n)***

+ 设置两个指针，分别指向两个数组的头，并创建一个大小与``nums1``相等的临时数组
+ 判断两个指针指向的值，直到某一个指针超出数组边界
  + 将==小==的一方==放入临时数组==中，同时指向这一方的指针向==下==一个位置偏移
+ 如果某个数组的指针超出边界，则直接操作另一个数组的指针，直到其超出边界
+ 最后用临时数组覆盖``nums1``

==**解法2：逆向双指针**==	***T=O(m+n), S=O(1)***

+ 因为``nums1``的末尾有预留``nums2``大小的空间，故可以从``nums1``尾部将元素从大开始排，节省了内存空间的消耗

+ 设置两个指针分别指向两个数组的尾（有效元素范围）

+ 同时设置第三个指针（可用``for``循环）负责指向``nums1``预留空间的尾

+ 判断两个指针指向的值，直到某一个指针超出边界

  + 将==大==的一方==放入==``nums1``中，同时指向这一方的指针向数组的==上==一个位置偏移

+ 如果某个数组的指针超出边界，则直接操作另一个数组的指针，直到其超出边界

#### 121 买卖股票的最佳实际

**==解法：动态规划==** 	***T=O(n), S=O(1)***

+ 核心思想：每天都在考虑当天的最大收益
  + 假设在某天打算==卖出==，那么在==这天之前==的==股价最低==的那天==买入==是收益最高的做法
+ 遍历数组，记录遍历过的元素中的最低值，记录每天的最大收益，遍历结束后找出每天最大收益中的最大值

> 上述最低值并不是数组中的最低值，而是遍历过程中，遍历过的数据中的最低值（动态最低值）

#### 118 杨辉三角

**==解法：暴力枚举==** 		***T=O(n^2^), S=O(1)***

+ 如果形参为0，则直接返回一个空数组
+ 初始化二维数组，行数是形参，每行的元素个数等于当前行号+1
+ 遍历数组的第一维
  + 重新指定第二维的长度的长度等于当前行号+1

  + 当前行的前后两个元素都设置为1

  + 行号大于1时（行号从0开始记），当前行的==非两端元素==等于其肩上两个元素之和


#### 217 存在重复元素

**==解法：哈希表==** 	***T=O(n), S=O(n)***

+ 创建哈希表，遍历数组中的每一个元素
  + 若在哈希表中查找到该元素，找到则返回真
  + 找不到则将该元素插入哈希表

#### 350 两个数组的交集II

**==解法1：哈希表==** 	***T=O(m+n), S=O(min(m, n))***

+ ==对比两个数组的大小==，将小者转存至哈希表，key值为数组的元素，value为该元素出现的次数
  +  可以主观认为形参列表中前者（``nums1``）为小数组，若前者大，则交换形参位置递归传递
  
  + ``hashmap[nums1[i]]++; //如果nums1[i]在哈希表中存在，则value自加；若不存在，则创建新的key并且value自加``
  
+ 遍历``nums2``（大的数组），利用哈希表的计数函数判断当前元素是否存在于哈希表中
  + 存在则将当前数组元素压入交集数组，并且哈希表对应的value值自减
  + 如果哈希表中某个value值为零，则删除该key值

**==解法2：双指针==**	 ***T=O(mlogm+nlogn), S=O(min(m, n))***

+ 两个数组排序

+ 两个指针分别指向两个数组的开头
+ 对比指针指向的值，直到某一个指针超出数组边界
  + 小的一方指针向右偏移
  + 相等则将当前值添加到交集数组

> 排序算法``sort()``的时间复杂度为***O(nlogn)***

#### 566 重塑矩阵

**==解法：矩阵映射==**	 ***T=O(m\*n), S=O(1)		此处空间复杂度不包含返回的矩阵需要的空间***

+ 一个 ***m\*n*** 的二维数组可以按行展开逐一对应映射到整数域 ***x∈[0, mn)***
  + 数组中的每一个元素 ***(i, j)*** ，按行次序映射到整数域的坐标是 ***x=i\*n+j***
  + 同理，可以按行次序将整数域的坐标映射回数组中：***i=x/n; j=x%n***
+ 故可以遍历整数域上的每一个位置，利用上述转换重塑数组

> 二维vector的初始化：``vector<vector<int>> v(r, vector<int>(c, 0));//形参列表中r是元素个数（行），后者是元素``

### B.字符串

#### 242 有效的字母异位词

**==解法1：排序后对比==**	 ***T=O(nlogn), S=O(logn), 排序导致的复杂度***

+ 两个字符串对比大小，不相同则直接返回假
+ 大小相同时对两个字符串排序，排序结果相同则返回真

**==解法2：哈希表==**	 ***T=O(n), S=O(1)***

+ 两个字符串对比大小，不相同则直接返回假
+ 创建一个哈希表（因为本题操作的是26个英文字母，故可以用一个26位的整型数组作为哈希表）
+ 遍历字符串``s``
  + 当一个字符在``s``中出现时，在数组中对应的位置自加
  + 当一个字符在``t``中出现时，在数组中对应的位置自减
+ 遍历哈希表，所有元素为0则返回真

> 字符型用整型表示的方式：``小写字符变量 - 'a'``，本质上是两者ASCII码的差值，0~25正好对应26个字母

#### 344 反转字符串

**==解法：双指针==**	  ***T=O(n), S=O(1)***

+ 假设数组长度为``n``，对数组元素``s[i]``，其总是和``s[n-1-i]``交换
+ 遍历数组的前半（``i<s.size()/2``即可），将其与后半交换

#### 383 赎金信

**==解法1：哈希表==**	   ***T=O(m+r), S=O(m)***

+ 遍历``magazine``，将==出现的字符==作为哈希表的key，==频数==作为value存入哈希表中（哈希表可用26位的整形数组）
+ 遍历``ransomNote``，在哈希表中对比当前字符的频数
  + 大于0则哈希表对应的``value``自减
  + 否则返回假

**==解法2：查找后删除==** 	***T=O(m\*r), S=O(1)***

+ 遍历``ransomNote``，在``magazine``中``find``当前字符
  + 找到则在``magazine``中``erase``该字符
  + 否则返回假

#### 387 字符串中的第一个唯一字符

**==解法1：哈希表（存频数）==**	 ***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存字符出现的频数，遍历字符串一次，更新哈希表
+ 再次遍历字符串，与哈希表进行对比，当出现某个字符只出现了一次时，返回索引

**==解法2：哈希表（存索引)==** 	***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存这个字符的索引，遍历字符串
  + 若该字符第一次出现，记录字符的索引
  + 若该字符非第一次出现，将其索引值改为``-1``
+ 创建一个整型``res``存储答案，初始化为``n``
+ 遍历哈希表，对于所有``value!=-1``的字符，如果该字符索引小于``res``，则更新答案

**==解法3：哈希表配合队列==**	 ***T=O(n), S=O(|n1|), 其中 |n1|<=n***

+ 哈希表的key存字符，value存索引，遍历字符串
  + 若该字符第一次出现，则存入哈希表，同时压入队列
  + 若非第一次出现，则将其索引改为-1，同时反复判断队列头
    + 若队列头不为空且队列头对应的元素在哈希表中的value值为-1，出队
+ 遍历字符串结束后，若队列不为空，则返回队列头对应元素的索引，否则返回-1

**==解法4：字符串查找函数==**	 ***T=O(n), S=O(1)***  **※最优解法※**

+ 字符串有实现查找功能的成员函数：``find()``和``rfind()``，分别是顺序查找和倒序查找
+ 遍历字符串，对所有字符而言，若顺序查找和倒序查找返回的索引相同，则代表这是第一个非重复字符

### C. 链表

#### 21 合并两个有序链表

**==解法1：递归==**	 ***T=O(m+n), S=O(m+n)***

+ 如果两个链表中有一个为空，则返回另一个
+ 判断链表头的数据域的值，假设``list1``的较小
  + 将``list1->next``指向函数``mergeTwoLists``（递归）的返回值，同时传递形参时要传入除去表头的``list1``
    + ``mergeTwoLists``的返回值就是合并后新链表的表头
  
  + 递归的终点是某一个链表为空

**==解法2：迭代==**	 ***T=O(m+n), S=O(1)***

+ 创建一个虚拟头，可用任意数据初始化
+ 创建一个``curr``指针指向虚拟头，该指针表示当前正在操作的节点
+ 如果两个链表都不为空
  + 对比此时两个==链表头的值==，创建一个指向==前述比较小者指针==的指针``pp``
  + 将``curr``节点的``next``指向``pp``所指向的指针所代表的节点，并且移动``curr``至该节点
  + 利用``pp``操作对应的链表指针到下一个节点
+ 进一步将非空的链表接在``curr``后面
+ 新建一个``res``指针指向虚拟头的下一个节点（在逻辑上就是链表合并后的头节点）
+ 释放虚拟头的内存，返回``res``作为答案

> 创建``dummy``是因为不知道合并后的链表头原先属于哪个链表，用``dummy``可以方便后续操作
>
> 创建指向指针的指针``pp``是因为对两个链表所进行的操作是一样的，唯独变量名不一样
>
> 所以利用一个指向指针的指针可以方便的操作需要操作的链表（节省代码量）
>
> 本质上，``curr``指针就是为了操作当前节点的指针域，而``pp``就标示了指针域应该指向的目标节点

#### 141 环形链表

**==解法1：哈希表==** 	***T=O(n), S=O(n)***

+ 创建哈希表（set容器）存指针，遍历链表
  + 若哈希表中已存在当前节点，返回真
  + 若哈希表不存在当前节点，则将其放入哈希表
+ 遍历结束后代表不存在环形结构

**==解法2：快慢指针（Floyd判圈算法）==** 	 ***T=O(n), S=O(1)***

+ 创建一快一慢两个指针，从链表头开始，慢指针每次移动一步，快指针每次移动两步
+ 如果快指针最终追上了慢指针，则代表链表存在环形结构
+ 否则环形结构不存在

#### 83 删除排序链表中的重复元素

**==解法1：迭代==**  	***T=O(n), S=O(1)***

+ 创建快慢指针，慢指针指向头节点，快指针指向头节点的下一个节点
+ 当快指针不为空时
  + 判断此时慢指针的数据域是否等于快指针的数据域
    + 相等：快指针移向下一个节点，慢指针的指针域指向快指针节点
    + 不等：慢指针节点等于快指针节点，快指针移向下一个节点

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 问题可以分解成头指针节点``head``和后续完成了删除操作的链表的头指针``nextHead``进行对比
  + 对比结果若相等，则``head->next = nextHead->next;``

+ 上述的后续链表的删除操作遵循同一原理

#### 203 移除链表元素

**==解法1：递归==**	 ***T=O(n), S=O(n)***

+ 整个链表删除特定元素，可以分解成头节点（未判断）+后续链表（判断完成）
+ 此时判断头节点的数据域是否需要被删除
  + 需要删除则将头指针移向下一个节点（后续链表的头）
  + 否则将头节点的指针域指向后续链表

**==解法2：迭代（双指针）==**	  ***T=O(n), S=O(1)***

+ 为当前链表创建一个虚拟头，虚拟头的指针域指向当前链表的头节点
+ 创建快慢指针，慢指针指向虚拟头，快指针指向链表实际的头
+ 如果快指针不为空
  + 判断快指针节点数据域的内容
    + 删除的操作是直接让慢指针节点跳过快指针，指向快指针的下一个节点，同时快指针移动至慢指针的下一个节点
    + 如果不需要删除，则慢指针移动至快指针的位置，快指针移动至下一个节点
+ 重新指定链表头为虚拟头的下一个节点
+ 释放虚拟头的内存

#### 206 反转链表

**==解法1：迭代==**	  ***T=O(n), S=O(1)***

+ 利用双指针+原本的``head``指针进行迭代
+ 原本链表的头节点在反转后是尾结点，指向空，故创建一个前指针``prev``，初始化为``nullptr``
+ 再创建一个现指针``curr``，指向``head``，也就是头节点，该指针将从原链表的头遍历指尾
+ 迭代条件：``curr``指针不为空（为空代表已经将指针遍历完毕）
  + 让``head``指针指向下一个节点，为了后续移动``curr``
  + ``curr``所指向的节点的指针域改为指向``curr``的前一个节点``prev``（最开始时是``nullptr``)
  + 将``prev``移动至``curr``的位置，``curr``移动至当前``head``的位置（也就是原链表的下一个节点）

**==解法2：递归==** 	***T=O(n), S=O(n)***

+ 整个链表的反转，可以看成是头节点和后续链表整体（已经完成反转）进行反转
  + ``head->next->next = head``

+ 相邻两层递归之间的关系是头节点指针域所指向的下一层的指针域指向头节点，然后头节点指针域置空

#### 234 回文链表

**==解法1：栈==**	 ***T=O(n), S=O(n)***

+ 链表数据从头开始压入栈
+ 再次遍历链表，判断栈顶是否与当前链表节点的数据域相等，相等则出栈
+ 遍历后如果栈为空，则代表这是回文链表

**==解法2：数组+双指针==**	 ***T=O(n), S=O(n)***

+ 遍历链表存入数组，利用双指针判断数组是否回文

**==解法3（最优解法）：快慢指针求中点+反转（用迭代算法啊）+遍历==**

+ 详情参考 ***剑指Offer 02.06.***

