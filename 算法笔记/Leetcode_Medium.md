# LeetCode_Medium

## A. 数组

### 36 有效的数组

**解法：**==哈希表== ***T=O(1), S=O(1)***

+ 分别用三个哈希表（本题可以用二维数组）记录每个数字在它所在的行、列、盒内的出现情况

  + 二维数组的第一维索引表示的是``board[i][j]``所在的*** 行/列/盒***
  + 第二维索引表示的是``curNum``，即``board[i][j]``所表示的数字 1~9，又因索引从0开始，故``curNum-1``
  + 所有哈希表的所有值都初始化为0，表示该数字（第二维）在该行/列/盒（第一维）未出现
  + 以行为例，``row[i][curNum]``表示的是``curNum``在``board[i]``出现与否（0-未出现；1-出现）

  + 盒的索引的原理：
    + 9*9的九宫格中一共有3\*3个子九宫格（画图理解）
    + 最直接的逻辑是用一个三维数组来实现，``box[i/3][j/3][curNum]``
    + ``i/3``表示当前盒的行数，``j/3``表示当前盒的列数，``curNum``同前
    + 也可以降至二维处理，单纯用 0~8 的序号认定所有的盒
    + 画图分析可得当前盒的序号为``(i/3)*3 + j/3``，故降至二维，与行列的哈希表维数一致

+ 遍历``board``

  + 如果出现``'.'``则``continue``
  + 对于所有的数字，分别与三个哈希表进行对比如果存在（哈希表``value==1``）则数独无效
  + 若都不存在，三个哈希表相应的``value=1``

### 73 矩阵置零

**解法1：**==标记数组== ***T=O(m\*n), S=O(m+n)***

+ 已知``matrix``行数为 m 列数为 n，创建两个标志数组``row[m]``和``column[n]``，用0初始化
+ 遍历``matrix``
  + 若``matrix[i][j]==0``，则``row[i]=column[j]=1``
+ 再次遍历``matrix``
  + 如果``row[i]``和``column[j]``其中之一等于1，则``matrix[i][j]=0``

**解法2：**==标记变量== ***T=O(m\*n), S=O(1)***

+ 创建两个标记变量``flagRow0``和``flagCol0``，初始化为0
+ 对于``matrix``的首行首列进行遍历，存在0则对应的 标记变量 置1
+ 遍历``matrix``除了首行首列以外的部分，并将首行首列作为 标记数组（参考解法1）
  + 若``matrix[i][j]==0``，则``flagRow0[i]=flagCol[j]=0``（此时0代表真，与解法1略有区别）
+ 再次遍历``matrix``除了首行首列以外的部分，利用标记数组更新``matrix[i][j]``

+ 再利用两个标记变量更新``matrix``的首行首列

> **重要！** 在解法2中，标记数组（首行首列）必须用0代表真
>
> 如果``matrix[i][j]==0``为真，则``matrix[i][0]``和``matrix[0][j]``最终也会被更新为0
>
> 但如果用1代表真，则后续利用标记数组（**首行首列**）更新``matrix``其余部分时会导致**二义性**